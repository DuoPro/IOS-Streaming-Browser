<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>IOS Streaming Browser: GCDAsyncReadPacket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Icon.png"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">IOS Streaming Browser&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">An IOS streaming browser to stream the display to others or to a projector</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('interface_g_c_d_async_read_packet.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<h1>GCDAsyncReadPacket Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="GCDAsyncReadPacket" --><div class="dynheader">
Collaboration diagram for GCDAsyncReadPacket:</div>
<div class="dyncontent">
<div class="center"><img src="interface_g_c_d_async_read_packet__coll__graph.png" border="0" usemap="#_g_c_d_async_read_packet_coll__map" alt="Collaboration graph"/></div>
<map name="_g_c_d_async_read_packet_coll__map" id="_g_c_d_async_read_packet_coll__map">
<area shape="rect" id="node2" href="class_n_s_data.html" title="NSData" alt="" coords="57,6,129,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_g_c_d_async_read_packet-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_read_packet.html#ab0735cd2830b86e4ab4c4811529d6250">initWithData:startOffset:maxLength:timeout:readLength:terminator:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_read_packet.html#a771662910118b78de8db67d7a5467c19">ensureCapacityForAdditionalDataOfLength:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSUInteger)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_read_packet.html#a47a4e7ec5cef39b518eeed1945521d56">optimalReadLengthWithDefault:shouldPreBuffer:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSUInteger)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_read_packet.html#a802a921f83dbf743a669e24b1eb0606d">readLengthForNonTermWithHint:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSUInteger)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_read_packet.html#a6e2570f8a47dd791a0d244bcad8fbf5b">readLengthForTermWithHint:shouldPreBuffer:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSUInteger)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_read_packet.html#a8fb46d3ba9cde4c7d4b57d790d504379">readLengthForTermWithPreBuffer:found:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSInteger)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_read_packet.html#aa032e1c07841b0c1ad437c88fbc580ec">searchForTermAfterPreBuffering:</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad81ba9e0403b0e01ea04d2af7f42f6e9"></a><!-- doxytag: member="GCDAsyncReadPacket::buffer" ref="ad81ba9e0403b0e01ea04d2af7f42f6e9" args="" -->
NSMutableData *&#160;</td><td class="memItemRight" valign="bottom"><b>buffer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1e38c3473418e18e452aebfb61401bb"></a><!-- doxytag: member="GCDAsyncReadPacket::startOffset" ref="af1e38c3473418e18e452aebfb61401bb" args="" -->
NSUInteger&#160;</td><td class="memItemRight" valign="bottom"><b>startOffset</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57d3b687812ec6c0cb32ce2a0d13ac27"></a><!-- doxytag: member="GCDAsyncReadPacket::bytesDone" ref="a57d3b687812ec6c0cb32ce2a0d13ac27" args="" -->
NSUInteger&#160;</td><td class="memItemRight" valign="bottom"><b>bytesDone</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30ac2f93832fbf93800193ec256ec384"></a><!-- doxytag: member="GCDAsyncReadPacket::maxLength" ref="a30ac2f93832fbf93800193ec256ec384" args="" -->
NSUInteger&#160;</td><td class="memItemRight" valign="bottom"><b>maxLength</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1268ca19a05015bc85c8105f1ce78876"></a><!-- doxytag: member="GCDAsyncReadPacket::timeout" ref="a1268ca19a05015bc85c8105f1ce78876" args="" -->
NSTimeInterval&#160;</td><td class="memItemRight" valign="bottom"><b>timeout</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa30af1129977b2b21a3ccac388c8cef3"></a><!-- doxytag: member="GCDAsyncReadPacket::readLength" ref="aa30af1129977b2b21a3ccac388c8cef3" args="" -->
NSUInteger&#160;</td><td class="memItemRight" valign="bottom"><b>readLength</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a513f951acaf4293c3feac8ccd8f7f092"></a><!-- doxytag: member="GCDAsyncReadPacket::term" ref="a513f951acaf4293c3feac8ccd8f7f092" args="" -->
<a class="el" href="class_n_s_data.html">NSData</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>term</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a132cc542e10157f818edc1c64f106227"></a><!-- doxytag: member="GCDAsyncReadPacket::bufferOwner" ref="a132cc542e10157f818edc1c64f106227" args="" -->
BOOL&#160;</td><td class="memItemRight" valign="bottom"><b>bufferOwner</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3592eb27d223e7b83c3b02764aaccc6e"></a><!-- doxytag: member="GCDAsyncReadPacket::originalBufferLength" ref="a3592eb27d223e7b83c3b02764aaccc6e" args="" -->
NSUInteger&#160;</td><td class="memItemRight" valign="bottom"><b>originalBufferLength</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a444a19df40e670caff546752fefcf2ef"></a><!-- doxytag: member="GCDAsyncReadPacket::tag" ref="a444a19df40e670caff546752fefcf2ef" args="" -->
long&#160;</td><td class="memItemRight" valign="bottom"><b>tag</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="interface_g_c_d_async_read_packet.html">GCDAsyncReadPacket</a> encompasses the instructions for any given read. The content of a read packet allows the code to determine if we're:</p>
<ul>
<li>reading to a certain length</li>
<li>reading to a certain separator</li>
<li>or simply reading the first chunk of available data </li>
</ul>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a771662910118b78de8db67d7a5467c19"></a><!-- doxytag: member="GCDAsyncReadPacket::ensureCapacityForAdditionalDataOfLength:" ref="a771662910118b78de8db67d7a5467c19" args="(NSUInteger bytesToRead)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) ensureCapacityForAdditionalDataOfLength: </td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>bytesToRead</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ensure the read buffer has the capacity for additional data param NSUInteger</p>
<p>Increases the length of the buffer (if needed) to ensure a read of the given size will fit. param NSUInteger </p>

</div>
</div>
<a class="anchor" id="ab0735cd2830b86e4ab4c4811529d6250"></a><!-- doxytag: member="GCDAsyncReadPacket::initWithData:startOffset:maxLength:timeout:readLength:terminator:tag:" ref="ab0735cd2830b86e4ab4c4811529d6250" args="(NSMutableData *d,[startOffset] NSUInteger s,[maxLength] NSUInteger m,[timeout] NSTimeInterval t,[readLength] NSUInteger l,[terminator] NSData *e,[tag] long i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithData: </td>
          <td></td>
          <td class="paramtype">(NSMutableData *)&#160;</td>
          <td class="paramname"><em>d</em></td>
        </tr>
        <tr>
          <td class="paramkey">startOffset:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>s</em></td>
        </tr>
        <tr>
          <td class="paramkey">maxLength:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>m</em></td>
        </tr>
        <tr>
          <td class="paramkey">timeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>t</em></td>
        </tr>
        <tr>
          <td class="paramkey">readLength:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>l</em></td>
        </tr>
        <tr>
          <td class="paramkey">terminator:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>e</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param NSMutableData param NSUInteger param NSUInteger param NSTimeInterval param NSUInteger param <a class="el" href="class_n_s_data.html">NSData</a> param long returns id</p>
<p>Initialize the <a class="el" href="interface_g_c_d_async_read_packet.html">GCDAsyncReadPacket</a> param NSMutableData param NSUInteger param NSUInteger param NSTimeInterval param NSUInteger param <a class="el" href="class_n_s_data.html">NSData</a> param long returns id </p>

</div>
</div>
<a class="anchor" id="a47a4e7ec5cef39b518eeed1945521d56"></a><!-- doxytag: member="GCDAsyncReadPacket::optimalReadLengthWithDefault:shouldPreBuffer:" ref="a47a4e7ec5cef39b518eeed1945521d56" args="(NSUInteger defaultValue,[shouldPreBuffer] BOOL *shouldPreBufferPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSUInteger) optimalReadLengthWithDefault: </td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>defaultValue</em></td>
        </tr>
        <tr>
          <td class="paramkey">shouldPreBuffer:</td>
          <td></td>
          <td class="paramtype">(BOOL *)&#160;</td>
          <td class="paramname"><em>shouldPreBufferPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The optimal read length with a default value, and whether should prebuffer param NSUInteger param BOOL returns NSUInteger</p>
<p>This method is used when we do NOT know how much data is available to be read from the socket. This method returns the default value unless it exceeds the specified readLength or maxLength.</p>
<p>Furthermore, the shouldPreBuffer decision is based upon the packet type, and whether the returned value would fit in the current buffer without requiring a resize of the buffer. param NSUInteger param BOOL returns NSUInteger </p>

</div>
</div>
<a class="anchor" id="a802a921f83dbf743a669e24b1eb0606d"></a><!-- doxytag: member="GCDAsyncReadPacket::readLengthForNonTermWithHint:" ref="a802a921f83dbf743a669e24b1eb0606d" args="(NSUInteger bytesAvailable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSUInteger) readLengthForNonTermWithHint: </td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>bytesAvailable</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads length from data without a terminator param NSUInteger returns NSUInteger</p>
<p>For read packets without a set terminator, returns the amount of data that can be read without exceeding the readLength or maxLength.</p>
<p>The given parameter indicates the number of bytes estimated to be available on the socket, which is taken into consideration during the calculation.</p>
<p>The given hint MUST be greater than zero. param NSUInteger returns NSUInteger </p>

</div>
</div>
<a class="anchor" id="a6e2570f8a47dd791a0d244bcad8fbf5b"></a><!-- doxytag: member="GCDAsyncReadPacket::readLengthForTermWithHint:shouldPreBuffer:" ref="a6e2570f8a47dd791a0d244bcad8fbf5b" args="(NSUInteger bytesAvailable,[shouldPreBuffer] BOOL *shouldPreBufferPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSUInteger) readLengthForTermWithHint: </td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>bytesAvailable</em></td>
        </tr>
        <tr>
          <td class="paramkey">shouldPreBuffer:</td>
          <td></td>
          <td class="paramtype">(BOOL *)&#160;</td>
          <td class="paramname"><em>shouldPreBufferPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads length of data which has a terminator param NSUInteger param BOOL returns NSUInteger</p>
<p>For read packets with a set terminator, returns the amount of data that can be read without exceeding the maxLength.</p>
<p>The given parameter indicates the number of bytes estimated to be available on the socket, which is taken into consideration during the calculation.</p>
<p>To optimize memory allocations, mem copies, and mem moves the shouldPreBuffer boolean value will indicate if the data should be read into a prebuffer first, or if the data can be read directly into the read packet's buffer. param NSUInteger (count of bytes available to read) param BOOL returns NSUInteger </p>

</div>
</div>
<a class="anchor" id="a8fb46d3ba9cde4c7d4b57d790d504379"></a><!-- doxytag: member="GCDAsyncReadPacket::readLengthForTermWithPreBuffer:found:" ref="a8fb46d3ba9cde4c7d4b57d790d504379" args="(NSData *preBuffer,[found] BOOL *foundPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSUInteger) readLengthForTermWithPreBuffer: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>preBuffer</em></td>
        </tr>
        <tr>
          <td class="paramkey">found:</td>
          <td></td>
          <td class="paramtype">(BOOL *)&#160;</td>
          <td class="paramname"><em>foundPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads length of data which has a terminator but which is larger than the buffer so we need to prebuffer the data param <a class="el" href="class_n_s_data.html">NSData</a> param BOOL return NSUInteger</p>
<p>For read packets with a set terminator,returns the amount of data that can be read from the given preBuffer,without going over a terminator or the maxLength.</p>
<p>It is assumed the terminator has not already been read.</p>
<p>param <a class="el" href="class_n_s_data.html">NSData</a> param BOOL returns NSUInteger </p>

</div>
</div>
<a class="anchor" id="aa032e1c07841b0c1ad437c88fbc580ec"></a><!-- doxytag: member="GCDAsyncReadPacket::searchForTermAfterPreBuffering:" ref="aa032e1c07841b0c1ad437c88fbc580ec" args="(ssize_t numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSInteger) searchForTermAfterPreBuffering: </td>
          <td></td>
          <td class="paramtype">(ssize_t)&#160;</td>
          <td class="paramname"><em>numBytes</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Search for the terminator after prebuffering the data param ssize_t returns NSInteger</p>
<p>For read packets with a set terminator, scans the packet buffer for the term.</p>
<p>It is assumed the terminator had not been fully read prior to the new bytes.</p>
<p>If the term is found, the number of excess bytes after the term are returned.</p>
<p>If the term is not found, this method will return -1.</p>
<p>Note: A return value of zero means the term was found at the very en.</p>
<p>Prerequisites: The given number of bytes have been added to the end of our buffer. Our bytesDone variable has NOT been changed due to the prebuffered bytes.</p>
<p>param ssize_t returns NSInteger </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/willrubel/IOS-Streaming-Browser/IOS-Streaming-Browser/GCDAsyncSocket.m</li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="interface_g_c_d_async_read_packet.html">GCDAsyncReadPacket</a>      </li>
      <li class="footer">Generated on Fri Jun 3 2011 14:25:03 for IOS Streaming Browser by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Properties</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
