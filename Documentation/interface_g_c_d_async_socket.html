<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>IOS Streaming Browser: GCDAsyncSocket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Icon.png"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">IOS Streaming Browser&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">An IOS streaming browser to stream the display to others or to a projector</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('interface_g_c_d_async_socket.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>GCDAsyncSocket Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="GCDAsyncSocket" --><div class="dynheader">
Collaboration diagram for GCDAsyncSocket:</div>
<div class="dyncontent">
<div class="center"><img src="interface_g_c_d_async_socket__coll__graph.png" border="0" usemap="#_g_c_d_async_socket_coll__map" alt="Collaboration graph"/></div>
<map name="_g_c_d_async_socket_coll__map" id="_g_c_d_async_socket_coll__map">
<area shape="rect" id="node2" href="interface_g_c_d_async_write_packet.html" title="GCDAsyncWritePacket" alt="" coords="154,101,333,129"/><area shape="rect" id="node4" href="class_n_s_data.html" title="NSData" alt="" coords="207,6,279,34"/><area shape="rect" id="node7" href="interface_g_c_d_async_read_packet.html" title="GCDAsyncReadPacket" alt="" coords="357,101,533,129"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_g_c_d_async_socket-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2d422942c387bfaa9e65ac4eb9eba942">init</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#af1e9f7995ba07948f23cb441d14f7df3">initWithSocketQueue:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2acc29ad9908180ac8897a2d1ace2d2c">initWithDelegate:delegateQueue:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a928f5f65021efe000a8fdb870dd2e7b0">initWithDelegate:delegateQueue:socketQueue:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2eba8f0bc736c90df3332e36e06d30de">delegate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aed81eac721c788ddd2d77531422df31a">setDelegate:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ac3f33527738b5dfd19520a6ef3992801">synchronouslySetDelegate:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(dispatch_queue_t)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a67d10e7cfd3d880e7960b0f13e765519">delegateQueue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#afb2ef66b28a4ea5c0bfc943c51d2053d">setDelegateQueue:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ae24331d1128f067ab6a10cc2325f3524">synchronouslySetDelegateQueue:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a0ecd4139a7ca179e608078e5a5aa4dac">getDelegate:delegateQueue:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ad50a28ce05e978e4f77d0d5e5a43b377">setDelegate:delegateQueue:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aa73b3285e4aba9a2c17b3e86b7e1b8ee">synchronouslySetDelegate:delegateQueue:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a4bbd1c84aab50161ea003788cb88abf1">autoDisconnectOnClosedReadStream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a9cc5e539079bc42d46ec33dd43bbed53">setAutoDisconnectOnClosedReadStream:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a4f1f326605ff3abefbf9647db91d3881">isIPv4Enabled</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a6e9dab1dec79b1dc931f246de95d138e">setIPv4Enabled:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a6cb6d0d972faae18e40acaad15736151">isIPv6Enabled</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ac6941a96608c7dd8be4accdf5b8b7688">setIPv6Enabled:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ac701a9ffe46759ed2e2e84817e3a881c">isIPv4PreferredOverIPv6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aab5301b56fde5d73120f7e80a2fdfc87">setPreferIPv4OverIPv6:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a478519828098f75eb1831de787e21ad3">userData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a26ea92d533af7d0533e0ff390b7c748e">setUserData:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a3de1ab0ad1b46d4071b19c851d63cc98">acceptOnPort:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a13cf041f192701135d2ccd9fc8edc10f">acceptOnInterface:port:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a43ba53f89816c4c3dd8705f187c2419d">connectToHost:onPort:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2d367fa4b37447a669f4ef19b522baaf">connectToHost:onPort:withTimeout:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aab717bfc26b55de1dcb4da18b10087a4">connectToHost:onPort:viaInterface:withTimeout:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a25760a9bb1cf932dc174ce5b3adf8447">connectToAddress:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a60eba39fa61015b2032c0da2950679f6">connectToAddress:withTimeout:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ab3ceb2a4b62c88f1202369fcb8c33156">connectToAddress:viaInterface:withTimeout:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a6aac0567b521bec51b21d416944de522">disconnect</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ad0093c79f79bf6f67c030dc77b3d67c5">disconnectAfterReading</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a1c4588adab4ac57773e3b3a78907f59d">disconnectAfterWriting</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a25c08ab3a9992c9c5cc1bc5e2ff79d14">disconnectAfterReadingAndWriting</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a10056a2b522dcef57f504152118e3e2e">isDisconnected</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a4142950e55bb0360f1fc5ca2487f29fb">isConnected</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a99300e9a6ae7b70263a36f58e4197967">connectedHost</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a871294f26d9e18b850669456f62e019e">connectedPort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a08877f86b6d2cb3e1dbb67f86300aba3">localHost</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ae5fb325e175009929b7ef93e78879c9c">localPort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aa5335ecf7b47cceb8c7de7ed774c5c89">connectedAddress</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a4729d86e82885f95ba75853da263480a">localAddress</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a601b053635887e0e806c6048a59b443f">isIPv4</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#afe8f125e89051b9795f392d967ce4736">isIPv6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a19d9cbf0ad11001fec6d0d7356c29afc">readDataWithTimeout:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a88357813a6f92a079332fb03948ef391">readDataWithTimeout:buffer:bufferOffset:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a07f1d68ddd293188871327da6146d9d1">readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a4bcf76fb9c6f6d4096ae557ffdc1704c">readDataToLength:withTimeout:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a809c3ee372faddffea0ffbc13e2c42f5">readDataToLength:withTimeout:buffer:bufferOffset:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ae24961705f14d5874f97ac86f98bd79a">readDataToData:withTimeout:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a24aefd40c4b1d2204bc871f96fc63868">readDataToData:withTimeout:buffer:bufferOffset:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a83c3c2b258aa829a9336e1a84ece3bb5">readDataToData:withTimeout:maxLength:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a524f3cb12b54a67c51afb1b48c2b6e34">readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ac10926913689fda565d495dd53ce6b16">writeData:withTimeout:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a70408047b819b6e8063140281b69a67c">startTLS:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ad05fe74acc7a045fe423023efeec5d47">performBlock:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(int)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2ac1c7744b1711cb15944966ba20f1c6">socketFD</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(int)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ac1d5a563d5230b3fb2969133a9f2f705">socket4FD</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(int)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a4c06877731887f66a9bc476b61fcbf7a">socket6FD</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(SSLContextRef)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a8a89890a7da7749e9563640cb8b343a3">sslContext</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a93507b9a8f2ce3b88982cafbc3544b42">doAccept:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a889ef4cccbf90f858e5698d9030f6efe">startConnectTimeout:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72461e3a6f0a78bae4e4b672c5238276"></a><!-- doxytag: member="GCDAsyncSocket::endConnectTimeout" ref="a72461e3a6f0a78bae4e4b672c5238276" args="()" -->
(void)&#160;</td><td class="memItemRight" valign="bottom">- <b>endConnectTimeout</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44aab5278ec6f673bab48f8dbe2dab7c"></a><!-- doxytag: member="GCDAsyncSocket::doConnectTimeout" ref="a44aab5278ec6f673bab48f8dbe2dab7c" args="()" -->
(void)&#160;</td><td class="memItemRight" valign="bottom">- <b>doConnectTimeout</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ae780c2624e6d78e92b738f43369870fc">lookup:host:port:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a9bc3dca5cd675d47e43dee2447e477c5">lookup:didSucceedWithAddress4:address6:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a02c48caec85f0454705dfc06a3f5966e">lookup:didFail:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a844cbe87e27e1bbad644b1be5f43da04">connectWithAddress4:address6:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a8fdb857b60207196e5d88dafb1bc182a">didConnect:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a4c769df3ee19b5e2033ec0eadf70d456">didNotConnect:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aba0aa2c7ec11bead20f71403ea7ba694">closeWithError:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ae7209a138166d476d3fd5375b1d287f2">close</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a120dd009e5510f9e808759134978974d">maybeClose</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSError *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ab4cd97f6e801bc2afb014d870eeee5c8">badConfigError:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSError *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ab6bbde5148fb8ba1571424577f21bcf4">badParamError:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSError *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a1cecc4273af79b853fd0f7b656aedbfb">gaiError:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSError *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#afacf7851fae5f214bdbd0ad0e8bbfd59">errnoError</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSError *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2ec9a8b752baf3d6b5a96db1e8423a69">errnoErrorWithReason:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSError *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a5b502caa552f9ed4e13cb90f2cd090ff">connectTimeoutError</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSError *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#adfa2a23e17778ac54c2cc6c100a66fac">otherError:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a82f0b9f0fe979527e2cb753d31abc02c">connectedHost4</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a00125a32f49a1348dc258f15287ba0d5">connectedHost6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a4b1be871b6fd8bfe5813d24550d9c47e">connectedPort4</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a69561b6eace2c6bb41e25170c4caa0cd">connectedPort6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a39b5e0db29254bfc4f61ae32ef603d35">localHost4</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a51627ce6a95c2a549973f1fc5007e5ed">localHost6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ab01c7c0cac08d0264450e134f62092c6">localPort4</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a74aa01f42e06d4b9e3550b7aeb42b1f7">localPort6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ab6f2270f1b85e7ab2e31a4b2fc99ea8f">connectedHostFromSocket4:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a144c5f0d3acbed779399bfdf09b54074">connectedHostFromSocket6:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#af0e1c2f139c48c0f968752c696d485a4">connectedPortFromSocket4:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a82de7251f591b3f01622a1c6edf1f087">connectedPortFromSocket6:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a0d4f19fd6b358a2cb8b30052e7a4497f">localHostFromSocket4:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#abcfb7b8707d4b3a4934c53a080b8f279">localHostFromSocket6:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a638322810b8824f3eb3aaee60e342a71">localPortFromSocket4:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#af8551c92edaefdb1d2c2e2211788d368">localPortFromSocket6:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a5b0049edf16a98d098eec8defaa19e25">getInterfaceAddress4:address6:fromDescription:port:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a7494f8b50cb3c1e23914c46d71620522">setupReadAndWriteSourcesForNewlyConnectedSocket:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a6d3843736b927a2103e4d54ccdd407ac">suspendReadSource</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2b5918fe0055f396fdc0d4d970f28ccb">resumeReadSource</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2ecfc37c4758e86238b1b71967ed8734">suspendWriteSource</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2aaead7c26870c68de2da294c75766cf">resumeWriteSource</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#abd37101a5cdbf6e1a99da06515da3413">maybeDequeueRead</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aa3d9411752a4c43392e422afeac9261a">doReadData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a9176c8b1c3f8eb49bb366371a91fa8c2">doReadEOF</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#abd95611fa1b34fe56acebbd9c7928013">completeCurrentRead</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a3392702f9dddd36565df414d9a85dbae">endCurrentRead</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a6add59c82678059664c7b2c0f376ae23">setupReadTimerWithTimeout:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f25543aece6b386f2a54ceda6aa9294"></a><!-- doxytag: member="GCDAsyncSocket::doReadTimeout" ref="a4f25543aece6b386f2a54ceda6aa9294" args="()" -->
(void)&#160;</td><td class="memItemRight" valign="bottom">- <b>doReadTimeout</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2ffbe90a3308b1eeda444bac52598b69">doReadTimeoutWithExtension:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a9aa34b22c10b7a8aa24d48c425386a78">maybeDequeueWrite</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a0bdbf4cda190a881b1a6a1ee289ab836">doWriteData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a925a613e46c6254a3fda5633079b7e5a">completeCurrentWrite</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a4ce078bcc91a0ed17d85f49f286818bc">endCurrentWrite</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#abfef9c29a14799f680bd9fe94a119be6">setupWriteTimerWithTimeout:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99de9f41655a609f5e1fd8de86d1b695"></a><!-- doxytag: member="GCDAsyncSocket::doWriteTimeout" ref="a99de9f41655a609f5e1fd8de86d1b695" args="()" -->
(void)&#160;</td><td class="memItemRight" valign="bottom">- <b>doWriteTimeout</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a15c27cae3a0c581ec7b7ce08d1c48f77">doWriteTimeoutWithExtension:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a94a185938b550754fef77b4b888dc223">maybeStartTLS</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a1683685e83d38986bd046d968ddfb5a1">continueSSLHandshake</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#a3f41fe787e381c7af97783db95dad8d6">hostFromAddress:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#a1a8f7d6e4e4a498596ce839ba96b36ab">portFromAddress:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#a0ddc697464881c23d848492bdfab0552">getHost:port:fromAddress:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#aaf412f25d0e7fd0aa0a2f678c48cd60c">CRLFData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#a827b2f932dc5a5bb9afb3bb922c0e3bf">CRData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#a3200e4bd391e47d8d54feb220cfd1322">LFData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#a0ec17715f642213548c05050cbbdfeb2">ZeroData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#a0e8444ecc3d8e2982f917413ed391baa">hostFromAddress4:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#ae9d74d1cb4a5bb355b30d4192eba7c15">hostFromAddress6:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#a66725f4718e4d77a2a2b06392a0d4b83">portFromAddress4:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#a36cd4cc75bd3e2fa740105e77b02ab23">portFromAddress6:</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a124288d553282e12ac71638b4a5d3ee5"></a><!-- doxytag: member="GCDAsyncSocket::flags" ref="a124288d553282e12ac71638b4a5d3ee5" args="" -->
UInt16&#160;</td><td class="memItemRight" valign="bottom"><b>flags</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb0f1dbd6f7709a7710926fdd1e2bb39"></a><!-- doxytag: member="GCDAsyncSocket::config" ref="adb0f1dbd6f7709a7710926fdd1e2bb39" args="" -->
UInt16&#160;</td><td class="memItemRight" valign="bottom"><b>config</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a21b567384add155d21ae42dd5f38434f">delegate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dispatch_queue_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#ad94468240917f346e161380a61ebc56d">delegateQueue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe0a6ab78789a89895e8f050994cb526"></a><!-- doxytag: member="GCDAsyncSocket::socket4FD" ref="abe0a6ab78789a89895e8f050994cb526" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>socket4FD</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78e2de0fd619891278ad0ee5455a9e91"></a><!-- doxytag: member="GCDAsyncSocket::socket6FD" ref="a78e2de0fd619891278ad0ee5455a9e91" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>socket6FD</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a978bdffe6dbfab895b46adc43e99257a"></a><!-- doxytag: member="GCDAsyncSocket::connectIndex" ref="a978bdffe6dbfab895b46adc43e99257a" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>connectIndex</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a4d97c4cf21175a7142d8bafdb7890c"></a><!-- doxytag: member="GCDAsyncSocket::connectInterface4" ref="a1a4d97c4cf21175a7142d8bafdb7890c" args="" -->
<a class="el" href="class_n_s_data.html">NSData</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>connectInterface4</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7a4cad28e7a1709f96377adc95f49a1"></a><!-- doxytag: member="GCDAsyncSocket::connectInterface6" ref="ab7a4cad28e7a1709f96377adc95f49a1" args="" -->
<a class="el" href="class_n_s_data.html">NSData</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>connectInterface6</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34272026d070e4dd113ef7616fa76968"></a><!-- doxytag: member="GCDAsyncSocket::socketQueue" ref="a34272026d070e4dd113ef7616fa76968" args="" -->
dispatch_queue_t&#160;</td><td class="memItemRight" valign="bottom"><b>socketQueue</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5ee6c040b579eba7e97034acaecb06e"></a><!-- doxytag: member="GCDAsyncSocket::accept4Source" ref="ae5ee6c040b579eba7e97034acaecb06e" args="" -->
dispatch_source_t&#160;</td><td class="memItemRight" valign="bottom"><b>accept4Source</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a478b9732e9c4e2c834ef60d5b6e34bf3"></a><!-- doxytag: member="GCDAsyncSocket::accept6Source" ref="a478b9732e9c4e2c834ef60d5b6e34bf3" args="" -->
dispatch_source_t&#160;</td><td class="memItemRight" valign="bottom"><b>accept6Source</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ee004b9f4da17863c84cf63a01042fa"></a><!-- doxytag: member="GCDAsyncSocket::connectTimer" ref="a2ee004b9f4da17863c84cf63a01042fa" args="" -->
dispatch_source_t&#160;</td><td class="memItemRight" valign="bottom"><b>connectTimer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af96ef139b7dc9f4e73b0813862d6365c"></a><!-- doxytag: member="GCDAsyncSocket::readSource" ref="af96ef139b7dc9f4e73b0813862d6365c" args="" -->
dispatch_source_t&#160;</td><td class="memItemRight" valign="bottom"><b>readSource</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af49e5d716aabcf64274e553a2ca20164"></a><!-- doxytag: member="GCDAsyncSocket::writeSource" ref="af49e5d716aabcf64274e553a2ca20164" args="" -->
dispatch_source_t&#160;</td><td class="memItemRight" valign="bottom"><b>writeSource</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae93352b95731cb999a3f446c5f0f2e22"></a><!-- doxytag: member="GCDAsyncSocket::readTimer" ref="ae93352b95731cb999a3f446c5f0f2e22" args="" -->
dispatch_source_t&#160;</td><td class="memItemRight" valign="bottom"><b>readTimer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86262182040d5ffa8b5acf69a4e5f874"></a><!-- doxytag: member="GCDAsyncSocket::writeTimer" ref="a86262182040d5ffa8b5acf69a4e5f874" args="" -->
dispatch_source_t&#160;</td><td class="memItemRight" valign="bottom"><b>writeTimer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac697e336b1ed5d49066ed7dd617843d1"></a><!-- doxytag: member="GCDAsyncSocket::readQueue" ref="ac697e336b1ed5d49066ed7dd617843d1" args="" -->
NSMutableArray *&#160;</td><td class="memItemRight" valign="bottom"><b>readQueue</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1f23a43d0ebb9c15ea38b498e026687"></a><!-- doxytag: member="GCDAsyncSocket::writeQueue" ref="ab1f23a43d0ebb9c15ea38b498e026687" args="" -->
NSMutableArray *&#160;</td><td class="memItemRight" valign="bottom"><b>writeQueue</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5f3f788f91c7c6ef6c8cec68b7ea86a"></a><!-- doxytag: member="GCDAsyncSocket::currentRead" ref="ae5f3f788f91c7c6ef6c8cec68b7ea86a" args="" -->
<a class="el" href="interface_g_c_d_async_read_packet.html">GCDAsyncReadPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>currentRead</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd481e8605b093f8064a84dd08a7e669"></a><!-- doxytag: member="GCDAsyncSocket::currentWrite" ref="acd481e8605b093f8064a84dd08a7e669" args="" -->
<a class="el" href="interface_g_c_d_async_write_packet.html">GCDAsyncWritePacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>currentWrite</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70db943e9c46044f297c70779366577a"></a><!-- doxytag: member="GCDAsyncSocket::socketFDBytesAvailable" ref="a70db943e9c46044f297c70779366577a" args="" -->
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>socketFDBytesAvailable</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab56a70a18b6dfd6d3a47744b18bccb04"></a><!-- doxytag: member="GCDAsyncSocket::partialReadBuffer" ref="ab56a70a18b6dfd6d3a47744b18bccb04" args="" -->
NSMutableData *&#160;</td><td class="memItemRight" valign="bottom"><b>partialReadBuffer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a325069983276b2a60ae2892200ea18e5"></a><!-- doxytag: member="GCDAsyncSocket::sslContext" ref="a325069983276b2a60ae2892200ea18e5" args="" -->
SSLContextRef&#160;</td><td class="memItemRight" valign="bottom"><b>sslContext</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b3c00735de00c5aeec96233ff6164b4"></a><!-- doxytag: member="GCDAsyncSocket::sslReadBuffer" ref="a0b3c00735de00c5aeec96233ff6164b4" args="" -->
NSMutableData *&#160;</td><td class="memItemRight" valign="bottom"><b>sslReadBuffer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cf8cccfbca9c578c947f5d8f698a067"></a><!-- doxytag: member="GCDAsyncSocket::sslWriteCachedLength" ref="a7cf8cccfbca9c578c947f5d8f698a067" args="" -->
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>sslWriteCachedLength</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a56949c539124f9b2d07ca1fe2f5f1302">userData</a></td></tr>
</table>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a13cf041f192701135d2ccd9fc8edc10f"></a><!-- doxytag: member="GCDAsyncSocket::acceptOnInterface:port:error:" ref="a13cf041f192701135d2ccd9fc8edc10f" args="(NSString *interface,[port] UInt16 port,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) acceptOnInterface: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>interface</em></td>
        </tr>
        <tr>
          <td class="paramkey">port:</td>
          <td></td>
          <td class="paramtype">(UInt16)&#160;</td>
          <td class="paramname"><em>port</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is the same as acceptOnPort:error: with the additional option of specifying which interface to listen on.</p>
<p>For example, you could specify that the socket should only accept connections over ethernet, and not other interfaces such as wifi.</p>
<p>The interface may be specified by name (e.g. "en1" or "lo0") or by IP address (e.g. "192.168.4.34"). You may also use the special strings "localhost" or "loopback" to specify that the socket only accept connections from the local machine.</p>
<p>You can see the list of interfaces via the command line utility "ifconfig", or programmatically via the getifaddrs() function.</p>
<p>To accept connections on any interface pass nil, or simply use the acceptOnPort:error: method.</p>
<p>Whether accept connection on interface and port param NSString param UInt16 returns BOOL </p>

</div>
</div>
<a class="anchor" id="a3de1ab0ad1b46d4071b19c851d63cc98"></a><!-- doxytag: member="GCDAsyncSocket::acceptOnPort:error:" ref="a3de1ab0ad1b46d4071b19c851d63cc98" args="(UInt16 port,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) acceptOnPort: </td>
          <td></td>
          <td class="paramtype">(UInt16)&#160;</td>
          <td class="paramname"><em>port</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tells the socket to begin listening and accepting connections on the given port.</p>
<p>When a connection is accepted, a new instance of <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> will be spawned to handle it, and the socket:didAcceptNewSocket: delegate method will be invoked.</p>
<p>The socket will listen on all available interfaces (e.g. wifi, ethernet, etc) param (UInt16) port param NSError returns BOOL</p>
<p>Whether accept connection on a port (listen socket) port - A port number at which the receiver should accept connections. errPtr - The address of an NSError object pointer. In the event of an error, the pointer will be set to the NSError object describing the error</p>
<p>param UInt16 param NSError returns BOOL </p>

</div>
</div>
<a class="anchor" id="a4bbd1c84aab50161ea003788cb88abf1"></a><!-- doxytag: member="GCDAsyncSocket::autoDisconnectOnClosedReadStream" ref="a4bbd1c84aab50161ea003788cb88abf1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) autoDisconnectOnClosedReadStream </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Traditionally sockets are not closed until the conversation is over. However, it is technically possible for the remote endpoint to close its write stream. Our socket would then be notified that there is no more data to be read, but our socket would still be writeable and the remote endpoint could continue to receive our data.</p>
<p>The argument for this confusing functionality stems from the idea that a client could shut down its write stream after sending a request to the server, thus notifying the server there are to be no further requests. In practice, however, this technique did little to help server developers.</p>
<p>To make matters worse, from a TCP perspective there is no way to tell the difference from a read stream close and a full socket close. They both result in the TCP stack receiving a FIN packet. The only way to tell is by continuing to write to the socket. If it was only a read stream close, then writes will continue to work. Otherwise an error will be occur shortly (when the remote end sends us a RST (reset) packet).</p>
<p>In addition to the technical challenges and confusion, many high level socket/stream API's provide no support for dealing with the problem. If the read stream is closed, the API immediately declares the socket to be closed, and shuts down the write stream as well. In fact, this is what Apple's CFStream API does. It might sound like poor design at first, but in fact it simplifies development.</p>
<p>The vast majority of the time if the read stream is closed it's because the remote endpoint closed its socket. Thus it actually makes sense to close the socket at this point. And in fact this is what most networking developers want and expect to happen. However, if you are writing a server that interacts with a plethora of clients, you might encounter a client that uses the discouraged technique of shutting down its write stream. If this is the case, you can set this property to NO, and make use of the socketDidCloseReadStream delegate method.</p>
<p>The default value is YES. Whether automatically disconnecting upon the closing of a read stream returns BOOL</p>
<p>Whether to automatically disconnect upon closing the read stream returns BOOL </p>

</div>
</div>
<a class="anchor" id="ab4cd97f6e801bc2afb014d870eeee5c8"></a><!-- doxytag: member="GCDAsyncSocket::badConfigError:" ref="ab4cd97f6e801bc2afb014d870eeee5c8" args="(NSString *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSError *) badConfigError: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>msg</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param msg returns NSError </p>

</div>
</div>
<a class="anchor" id="ab6bbde5148fb8ba1571424577f21bcf4"></a><!-- doxytag: member="GCDAsyncSocket::badParamError:" ref="ab6bbde5148fb8ba1571424577f21bcf4" args="(NSString *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSError *) badParamError: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>msg</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param msg returns NSError </p>

</div>
</div>
<a class="anchor" id="ae7209a138166d476d3fd5375b1d287f2"></a><!-- doxytag: member="GCDAsyncSocket::close" ref="ae7209a138166d476d3fd5375b1d287f2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) close </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close the connection </p>

</div>
</div>
<a class="anchor" id="aba0aa2c7ec11bead20f71403ea7ba694"></a><!-- doxytag: member="GCDAsyncSocket::closeWithError:" ref="aba0aa2c7ec11bead20f71403ea7ba694" args="(NSError *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) closeWithError: </td>
          <td></td>
          <td class="paramtype">(NSError *)&#160;</td>
          <td class="paramname"><em>error</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param NSError </p>

</div>
</div>
<a class="anchor" id="abd95611fa1b34fe56acebbd9c7928013"></a><!-- doxytag: member="GCDAsyncSocket::completeCurrentRead" ref="abd95611fa1b34fe56acebbd9c7928013" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) completeCurrentRead </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Complete the current read </p>

</div>
</div>
<a class="anchor" id="a925a613e46c6254a3fda5633079b7e5a"></a><!-- doxytag: member="GCDAsyncSocket::completeCurrentWrite" ref="a925a613e46c6254a3fda5633079b7e5a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) completeCurrentWrite </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Completes the current write </p>

</div>
</div>
<a class="anchor" id="aa5335ecf7b47cceb8c7de7ed774c5c89"></a><!-- doxytag: member="GCDAsyncSocket::connectedAddress" ref="aa5335ecf7b47cceb8c7de7ed774c5c89" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="class_n_s_data.html">NSData</a> *) connectedAddress </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the local or remote address to which this socket is connected, specified as a sockaddr structure wrapped in a <a class="el" href="class_n_s_data.html">NSData</a> object.</p>
<p>See also the connectedHost, connectedPort, localHost and localPort methods.</p>
<p>returns <a class="el" href="class_n_s_data.html">NSData</a> </p>

</div>
</div>
<a class="anchor" id="a99300e9a6ae7b70263a36f58e4197967"></a><!-- doxytag: member="GCDAsyncSocket::connectedHost" ref="a99300e9a6ae7b70263a36f58e4197967" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) connectedHost </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected. The host will be an IP address. </p>

</div>
</div>
<a class="anchor" id="a82f0b9f0fe979527e2cb753d31abc02c"></a><!-- doxytag: member="GCDAsyncSocket::connectedHost4" ref="a82f0b9f0fe979527e2cb753d31abc02c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) connectedHost4 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns NSString </p>

</div>
</div>
<a class="anchor" id="a00125a32f49a1348dc258f15287ba0d5"></a><!-- doxytag: member="GCDAsyncSocket::connectedHost6" ref="a00125a32f49a1348dc258f15287ba0d5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) connectedHost6 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns NSString </p>

</div>
</div>
<a class="anchor" id="ab6f2270f1b85e7ab2e31a4b2fc99ea8f"></a><!-- doxytag: member="GCDAsyncSocket::connectedHostFromSocket4:" ref="ab6f2270f1b85e7ab2e31a4b2fc99ea8f" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) connectedHostFromSocket4: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns NSString </p>

</div>
</div>
<a class="anchor" id="a144c5f0d3acbed779399bfdf09b54074"></a><!-- doxytag: member="GCDAsyncSocket::connectedHostFromSocket6:" ref="a144c5f0d3acbed779399bfdf09b54074" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) connectedHostFromSocket6: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns NSString </p>

</div>
</div>
<a class="anchor" id="a871294f26d9e18b850669456f62e019e"></a><!-- doxytag: member="GCDAsyncSocket::connectedPort" ref="a871294f26d9e18b850669456f62e019e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) connectedPort </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns UInt16 </p>

</div>
</div>
<a class="anchor" id="a4b1be871b6fd8bfe5813d24550d9c47e"></a><!-- doxytag: member="GCDAsyncSocket::connectedPort4" ref="a4b1be871b6fd8bfe5813d24550d9c47e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) connectedPort4 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="a69561b6eace2c6bb41e25170c4caa0cd"></a><!-- doxytag: member="GCDAsyncSocket::connectedPort6" ref="a69561b6eace2c6bb41e25170c4caa0cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) connectedPort6 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="af0e1c2f139c48c0f968752c696d485a4"></a><!-- doxytag: member="GCDAsyncSocket::connectedPortFromSocket4:" ref="af0e1c2f139c48c0f968752c696d485a4" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) connectedPortFromSocket4: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="a82de7251f591b3f01622a1c6edf1f087"></a><!-- doxytag: member="GCDAsyncSocket::connectedPortFromSocket6:" ref="a82de7251f591b3f01622a1c6edf1f087" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) connectedPortFromSocket6: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="a5b502caa552f9ed4e13cb90f2cd090ff"></a><!-- doxytag: member="GCDAsyncSocket::connectTimeoutError" ref="a5b502caa552f9ed4e13cb90f2cd090ff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSError *) connectTimeoutError </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns NSError </p>

</div>
</div>
<a class="anchor" id="a25760a9bb1cf932dc174ce5b3adf8447"></a><!-- doxytag: member="GCDAsyncSocket::connectToAddress:error:" ref="a25760a9bb1cf932dc174ce5b3adf8447" args="(NSData *remoteAddr,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToAddress: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>remoteAddr</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connects to the given address, specified as a sockaddr structure wrapped in a <a class="el" href="class_n_s_data.html">NSData</a> object. For example, a <a class="el" href="class_n_s_data.html">NSData</a> object returned from NSNetservice's addresses method.</p>
<p>If you have an existing struct sockaddr you can convert it to a <a class="el" href="class_n_s_data.html">NSData</a> object like so: struct sockaddr sa -&gt; <a class="el" href="class_n_s_data.html">NSData</a> *dsa = [<a class="el" href="class_n_s_data.html">NSData</a> dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len]; struct sockaddr *sa -&gt; <a class="el" href="class_n_s_data.html">NSData</a> *dsa = [<a class="el" href="class_n_s_data.html">NSData</a> dataWithBytes:remoteAddr length:remoteAddr-&gt;sa_len];</p>
<p>This method invokes connectToAdd </p>

</div>
</div>
<a class="anchor" id="ab3ceb2a4b62c88f1202369fcb8c33156"></a><!-- doxytag: member="GCDAsyncSocket::connectToAddress:viaInterface:withTimeout:error:" ref="ab3ceb2a4b62c88f1202369fcb8c33156" args="(NSData *remoteAddr,[viaInterface] NSString *interface,[withTimeout] NSTimeInterval timeout,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToAddress: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>remoteAddr</em></td>
        </tr>
        <tr>
          <td class="paramkey">viaInterface:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>interface</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connects to the given address, using the specified interface and timeout.</p>
<p>The address is specified as a sockaddr structure wrapped in a <a class="el" href="class_n_s_data.html">NSData</a> object. For example, a <a class="el" href="class_n_s_data.html">NSData</a> object returned from NSNetservice's addresses method.</p>
<p>If you have an existing struct sockaddr you can convert it to a <a class="el" href="class_n_s_data.html">NSData</a> object like so: struct sockaddr sa -&gt; <a class="el" href="class_n_s_data.html">NSData</a> *dsa = [<a class="el" href="class_n_s_data.html">NSData</a> dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len]; struct sockaddr *sa -&gt; <a class="el" href="class_n_s_data.html">NSData</a> *dsa = [<a class="el" href="class_n_s_data.html">NSData</a> dataWithBytes:remoteAddr length:remoteAddr-&gt;sa_len];</p>
<p>The interface may be a name (e.g. "en1" or "lo0") or the corresponding IP address (e.g. "192.168.4.35"). The interface may also be used to specify the local port (see below).</p>
<p>The timeout is optional. To not time out use a negative time interval.</p>
<p>This method will return NO if an error is detected, and set the error pointer (if one was given). Possible errors would be a nil host, invalid interface, or socket is already connected.</p>
<p>If no errors are detected, this method will start a background connect operation and immediately return YES. The delegate callbacks are used to notify you when the socket connects, or if the host was unreachable.</p>
<p>Since this class supports queued reads and writes, you can immediately start reading and/or writing. All read/write operations will be queued, and upon socket connection, the operations will be dequeued and processed in order.</p>
<p>The interface may optionally contain a port number at the end of the string, separated by a colon. This allows you to specify the local port that should be used for the outgoing connection. (read paragraph to end) To specify both interface and local port: "en1:8082" or "192.168.4.35:2424". To specify only local port: ":8082". Please note this is an advanced feature, and is somewhat hidden on purpose. You should understand that 99.999% of the time you should NOT specify the local port for an outgoing connection. If you think you need to, there is a very good chance you have a fundamental misunderstanding somewhere. Local ports do NOT need to match remote ports. In fact, they almost never do. This feature is here for networking professionals using very advanced techniques.</p>
<p>param <a class="el" href="class_n_s_data.html">NSData</a> param NSString param NSTimeInterval param NSError returns BOOL </p>

</div>
</div>
<a class="anchor" id="a60eba39fa61015b2032c0da2950679f6"></a><!-- doxytag: member="GCDAsyncSocket::connectToAddress:withTimeout:error:" ref="a60eba39fa61015b2032c0da2950679f6" args="(NSData *remoteAddr,[withTimeout] NSTimeInterval timeout,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToAddress: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>remoteAddr</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is the same as connectToAddress:error: with an additional timeout option. To not time out use a negative time interval, or simply use the connectToAddress:error: method. param <a class="el" href="class_n_s_data.html">NSData</a> param NSTimeInterval param NSError returns BOOL </p>

</div>
</div>
<a class="anchor" id="a43ba53f89816c4c3dd8705f187c2419d"></a><!-- doxytag: member="GCDAsyncSocket::connectToHost:onPort:error:" ref="a43ba53f89816c4c3dd8705f187c2419d" args="(NSString *host,[onPort] UInt16 port,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToHost: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>host</em></td>
        </tr>
        <tr>
          <td class="paramkey">onPort:</td>
          <td></td>
          <td class="paramtype">(UInt16)&#160;</td>
          <td class="paramname"><em>port</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connects to the given host and port.</p>
<p>This method invokes connectToHost:onPort:viaInterface:withTimeout:error: and uses the default interface, and no timeout. param NSString param UInt16 returns BOOL</p>
<p>Whether can connect to a host on a particular port host - A DNS name or IP address to which the receiver should connect. Both IPv4 and IPv6 addresses are supported. port - A port number to which the receiver should connect. errPtr - The address of an NSError object pointer. In the event of an error, the pointer will be set to the NSError object describing the error.</p>
<p>param NSString param UInt16 param NSError returns BOOL </p>

</div>
</div>
<a class="anchor" id="aab717bfc26b55de1dcb4da18b10087a4"></a><!-- doxytag: member="GCDAsyncSocket::connectToHost:onPort:viaInterface:withTimeout:error:" ref="aab717bfc26b55de1dcb4da18b10087a4" args="(NSString *host,[onPort] UInt16 port,[viaInterface] NSString *interface,[withTimeout] NSTimeInterval timeout,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToHost: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>host</em></td>
        </tr>
        <tr>
          <td class="paramkey">onPort:</td>
          <td></td>
          <td class="paramtype">(UInt16)&#160;</td>
          <td class="paramname"><em>port</em></td>
        </tr>
        <tr>
          <td class="paramkey">viaInterface:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>interface</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connects to the given host &amp; port, via the optional interface, with an optional timeout.</p>
<p>The host may be a domain name (e.g. "deusty.com") or an IP address string (e.g. "192.168.0.2"). The interface may be a name (e.g. "en1" or "lo0") or the corresponding IP address (e.g. "192.168.4.35"). The interface may also be used to specify the local port (see below).</p>
<p>To not time out use a negative time interval.</p>
<p>This method will return NO if an error is detected, and set the error pointer (if one was given). Possible errors would be a nil host, invalid interface, or socket is already connected.</p>
<p>If no errors are detected, this method will start a background connect operation and immediately return YES. The delegate callbacks are used to notify you when the socket connects, or if the host was unreachable.</p>
<p>Since this class supports queued reads and writes, you can immediately start reading and/or writing. All read/write operations will be queued, and upon socket connection, the operations will be dequeued and processed in order.</p>
<p>The interface may optionally contain a port number at the end of the string, separated by a colon. This allows you to specify the local port that should be used for the outgoing connection. (read paragraph to end) To specify both interface and local port: "en1:8082" or "192.168.4.35:2424". To specify only local port: ":8082". Please note this is an advanced feature, and is somewhat hidden on purpose. You should understand that 99.999% of the time you should NOT specify the local port for an outgoing connection. If you think you need to, there is a very good chance you have a fundamental misunderstanding somewhere. Local ports do NOT need to match remote ports. In fact, they almost never do. This feature is here for networking professionals using very advanced techniques.</p>
<p>Whether can connect to host on specific port via a specific interface hostname - A DNS name or IP address to which the receiver should connect. Both IPv4 and IPv6 addresses are supported port - A port number to which the receiver should connect. errPtr - The address of an NSError object pointer. In the event of an error, the pointer will be set to the NSError object describing the error</p>
<p>param NSString param UInt16 param NSString param NSTimeInterval param NSError returns BOOL </p>

</div>
</div>
<a class="anchor" id="a2d367fa4b37447a669f4ef19b522baaf"></a><!-- doxytag: member="GCDAsyncSocket::connectToHost:onPort:withTimeout:error:" ref="a2d367fa4b37447a669f4ef19b522baaf" args="(NSString *host,[onPort] UInt16 port,[withTimeout] NSTimeInterval timeout,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToHost: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>host</em></td>
        </tr>
        <tr>
          <td class="paramkey">onPort:</td>
          <td></td>
          <td class="paramtype">(UInt16)&#160;</td>
          <td class="paramname"><em>port</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connects to the given host and port with an optional timeout.</p>
<p>This method invokes connectToHost:onPort:viaInterface:withTimeout:error: and uses the default interface. param NSString param UInt16 param NSTimeInterval param NSError returns BOOL</p>
<p>Whether can connect to host on a specific port via a specific interface with a specific timeout</p>
<p>param NSString param UInt16 param NSTimeInterval param NSError returns BOOL </p>

</div>
</div>
<a class="anchor" id="a844cbe87e27e1bbad644b1be5f43da04"></a><!-- doxytag: member="GCDAsyncSocket::connectWithAddress4:address6:error:" ref="a844cbe87e27e1bbad644b1be5f43da04" args="(NSData *address4,[address6] NSData *address6,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectWithAddress4: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>address4</em></td>
        </tr>
        <tr>
          <td class="paramkey">address6:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>address6</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param <a class="el" href="class_n_s_data.html">NSData</a> param <a class="el" href="class_n_s_data.html">NSData</a> param NSError returns BOOL </p>

</div>
</div>
<a class="anchor" id="a1683685e83d38986bd046d968ddfb5a1"></a><!-- doxytag: member="GCDAsyncSocket::continueSSLHandshake" ref="a1683685e83d38986bd046d968ddfb5a1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) continueSSLHandshake </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Continue the SSL handshake </p>

</div>
</div>
<a class="anchor" id="a827b2f932dc5a5bb9afb3bb922c0e3bf"></a><!-- doxytag: member="GCDAsyncSocket::CRData" ref="a827b2f932dc5a5bb9afb3bb922c0e3bf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (<a class="el" href="class_n_s_data.html">NSData</a> *) CRData </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method returns <a class="el" href="class_n_s_data.html">NSData</a> </p>

</div>
</div>
<a class="anchor" id="aaf412f25d0e7fd0aa0a2f678c48cd60c"></a><!-- doxytag: member="GCDAsyncSocket::CRLFData" ref="aaf412f25d0e7fd0aa0a2f678c48cd60c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (<a class="el" href="class_n_s_data.html">NSData</a> *) CRLFData </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A few common line separators, for use with the readDataToData:... methods. Class method returns <a class="el" href="class_n_s_data.html">NSData</a> </p>

</div>
</div>
<a class="anchor" id="a2eba8f0bc736c90df3332e36e06d30de"></a><!-- doxytag: member="GCDAsyncSocket::delegate" ref="a2eba8f0bc736c90df3332e36e06d30de" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) <a class="el" href="interface_g_c_d_async_socket.html#a21b567384add155d21ae42dd5f38434f">delegate</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the delegate returns id </p>

</div>
</div>
<a class="anchor" id="a67d10e7cfd3d880e7960b0f13e765519"></a><!-- doxytag: member="GCDAsyncSocket::delegateQueue" ref="a67d10e7cfd3d880e7960b0f13e765519" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (dispatch_queue_t) <a class="el" href="interface_g_c_d_async_socket.html#ad94468240917f346e161380a61ebc56d">delegateQueue</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the delegate queue returns dispatch_queue_t </p>

</div>
</div>
<a class="anchor" id="a8fdb857b60207196e5d88dafb1bc182a"></a><!-- doxytag: member="GCDAsyncSocket::didConnect:" ref="a8fdb857b60207196e5d88dafb1bc182a" args="(int aConnectIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) didConnect: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>aConnectIndex</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int </p>

</div>
</div>
<a class="anchor" id="a4c769df3ee19b5e2033ec0eadf70d456"></a><!-- doxytag: member="GCDAsyncSocket::didNotConnect:error:" ref="a4c769df3ee19b5e2033ec0eadf70d456" args="(int aConnectIndex,[error] NSError *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) didNotConnect: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>aConnectIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError *)&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int param NSError </p>

</div>
</div>
<a class="anchor" id="a6aac0567b521bec51b21d416944de522"></a><!-- doxytag: member="GCDAsyncSocket::disconnect" ref="a6aac0567b521bec51b21d416944de522" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disconnect </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disconnects immediately (synchronously). Any pending reads or writes are dropped. If the socket is not already disconnected, the socketDidDisconnect delegate method will be called immediately, before this method returns.</p>
<p>Please note the recommended way of releasing an AsyncSocket instance (e.g. in a dealloc method) [asyncSocket setDelegate:nil]; [asyncSocket disconnect]; [asyncSocket release]; </p>

</div>
</div>
<a class="anchor" id="ad0093c79f79bf6f67c030dc77b3d67c5"></a><!-- doxytag: member="GCDAsyncSocket::disconnectAfterReading" ref="ad0093c79f79bf6f67c030dc77b3d67c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disconnectAfterReading </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disconnects after all pending reads have completed. After calling this, the read and write methods will do nothing. The socket will disconnect even if there are still pending writes. </p>

</div>
</div>
<a class="anchor" id="a25c08ab3a9992c9c5cc1bc5e2ff79d14"></a><!-- doxytag: member="GCDAsyncSocket::disconnectAfterReadingAndWriting" ref="a25c08ab3a9992c9c5cc1bc5e2ff79d14" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disconnectAfterReadingAndWriting </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disconnects after all pending reads and writes have completed. After calling this, the read and write methods will do nothing. </p>

</div>
</div>
<a class="anchor" id="a1c4588adab4ac57773e3b3a78907f59d"></a><!-- doxytag: member="GCDAsyncSocket::disconnectAfterWriting" ref="a1c4588adab4ac57773e3b3a78907f59d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disconnectAfterWriting </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disconnects after all pending writes have completed. After calling this, the read and write methods will do nothing. The socket will disconnect even if there are still pending reads. </p>

</div>
</div>
<a class="anchor" id="a93507b9a8f2ce3b88982cafbc3544b42"></a><!-- doxytag: member="GCDAsyncSocket::doAccept:" ref="a93507b9a8f2ce3b88982cafbc3544b42" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) doAccept: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns boolean </p>

</div>
</div>
<a class="anchor" id="aa3d9411752a4c43392e422afeac9261a"></a><!-- doxytag: member="GCDAsyncSocket::doReadData" ref="aa3d9411752a4c43392e422afeac9261a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doReadData </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads data </p>

</div>
</div>
<a class="anchor" id="a9176c8b1c3f8eb49bb366371a91fa8c2"></a><!-- doxytag: member="GCDAsyncSocket::doReadEOF" ref="a9176c8b1c3f8eb49bb366371a91fa8c2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doReadEOF </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read until the end of file terminator </p>

</div>
</div>
<a class="anchor" id="a2ffbe90a3308b1eeda444bac52598b69"></a><!-- doxytag: member="GCDAsyncSocket::doReadTimeoutWithExtension:" ref="a2ffbe90a3308b1eeda444bac52598b69" args="(NSTimeInterval timeoutExtension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doReadTimeoutWithExtension: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeoutExtension</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provides for an extension of time param NSTimeInterval </p>

</div>
</div>
<a class="anchor" id="a0bdbf4cda190a881b1a6a1ee289ab836"></a><!-- doxytag: member="GCDAsyncSocket::doWriteData" ref="a0bdbf4cda190a881b1a6a1ee289ab836" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doWriteData </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes the data to the socket </p>

</div>
</div>
<a class="anchor" id="a15c27cae3a0c581ec7b7ce08d1c48f77"></a><!-- doxytag: member="GCDAsyncSocket::doWriteTimeoutWithExtension:" ref="a15c27cae3a0c581ec7b7ce08d1c48f77" args="(NSTimeInterval timeoutExtension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doWriteTimeoutWithExtension: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeoutExtension</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param NSTimeInterval </p>

</div>
</div>
<a class="anchor" id="a3392702f9dddd36565df414d9a85dbae"></a><!-- doxytag: member="GCDAsyncSocket::endCurrentRead" ref="a3392702f9dddd36565df414d9a85dbae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) endCurrentRead </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop the current read Cancel the timer and release the current writer </p>

</div>
</div>
<a class="anchor" id="a4ce078bcc91a0ed17d85f49f286818bc"></a><!-- doxytag: member="GCDAsyncSocket::endCurrentWrite" ref="a4ce078bcc91a0ed17d85f49f286818bc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) endCurrentWrite </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel the timer and release the current writer </p>

</div>
</div>
<a class="anchor" id="afacf7851fae5f214bdbd0ad0e8bbfd59"></a><!-- doxytag: member="GCDAsyncSocket::errnoError" ref="afacf7851fae5f214bdbd0ad0e8bbfd59" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSError *) errnoError </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns NSError </p>

</div>
</div>
<a class="anchor" id="a2ec9a8b752baf3d6b5a96db1e8423a69"></a><!-- doxytag: member="GCDAsyncSocket::errnoErrorWithReason:" ref="a2ec9a8b752baf3d6b5a96db1e8423a69" args="(NSString *reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSError *) errnoErrorWithReason: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>reason</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param NSString returns NSError </p>

</div>
</div>
<a class="anchor" id="a1cecc4273af79b853fd0f7b656aedbfb"></a><!-- doxytag: member="GCDAsyncSocket::gaiError:" ref="a1cecc4273af79b853fd0f7b656aedbfb" args="(int gai_error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSError *) gaiError: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>gai_error</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns NSError </p>

</div>
</div>
<a class="anchor" id="a0ecd4139a7ca179e608078e5a5aa4dac"></a><!-- doxytag: member="GCDAsyncSocket::getDelegate:delegateQueue:" ref="a0ecd4139a7ca179e608078e5a5aa4dac" args="(id *delegatePtr,[delegateQueue] dispatch_queue_t *delegateQueuePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) getDelegate: </td>
          <td></td>
          <td class="paramtype">(id *)&#160;</td>
          <td class="paramname"><em>delegatePtr</em></td>
        </tr>
        <tr>
          <td class="paramkey">delegateQueue:</td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t *)&#160;</td>
          <td class="paramname"><em>delegateQueuePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get delegate and delegate queue param id param dispatch_queue_t</p>
<p>Gets the delegate point and delegate queue pointer param id param dispatch_queue_t </p>

</div>
</div>
<a class="anchor" id="a0ddc697464881c23d848492bdfab0552"></a><!-- doxytag: member="GCDAsyncSocket::getHost:port:fromAddress:" ref="a0ddc697464881c23d848492bdfab0552" args="(NSString **hostPtr,[port] UInt16 *portPtr,[fromAddress] NSData *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (BOOL) getHost: </td>
          <td></td>
          <td class="paramtype">(NSString **)&#160;</td>
          <td class="paramname"><em>hostPtr</em></td>
        </tr>
        <tr>
          <td class="paramkey">port:</td>
          <td></td>
          <td class="paramtype">(UInt16 *)&#160;</td>
          <td class="paramname"><em>portPtr</em></td>
        </tr>
        <tr>
          <td class="paramkey">fromAddress:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method param NSString (pointer to a pointer) param UInt16 param <a class="el" href="class_n_s_data.html">NSData</a> returns BOOL </p>

</div>
</div>
<a class="anchor" id="a5b0049edf16a98d098eec8defaa19e25"></a><!-- doxytag: member="GCDAsyncSocket::getInterfaceAddress4:address6:fromDescription:port:" ref="a5b0049edf16a98d098eec8defaa19e25" args="(NSData **addr4Ptr,[address6] NSData **addr6Ptr,[fromDescription] NSString *interfaceDescription,[port] UInt16 port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) getInterfaceAddress4: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> **)&#160;</td>
          <td class="paramname"><em>addr4Ptr</em></td>
        </tr>
        <tr>
          <td class="paramkey">address6:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> **)&#160;</td>
          <td class="paramname"><em>addr6Ptr</em></td>
        </tr>
        <tr>
          <td class="paramkey">fromDescription:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>interfaceDescription</em></td>
        </tr>
        <tr>
          <td class="paramkey">port:</td>
          <td></td>
          <td class="paramtype">(UInt16)&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param <a class="el" href="class_n_s_data.html">NSData</a> param <a class="el" href="class_n_s_data.html">NSData</a> param NSString param unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="a0e8444ecc3d8e2982f917413ed391baa"></a><!-- doxytag: member="GCDAsyncSocket::hostFromAddress4:" ref="a0e8444ecc3d8e2982f917413ed391baa" args="(struct sockaddr_in *pSockaddr4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (NSString *) hostFromAddress4: </td>
          <td></td>
          <td class="paramtype">(struct sockaddr_in *)&#160;</td>
          <td class="paramname"><em>pSockaddr4</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method param struct sockaddr_in (IP version 4) returns NSString </p>

</div>
</div>
<a class="anchor" id="ae9d74d1cb4a5bb355b30d4192eba7c15"></a><!-- doxytag: member="GCDAsyncSocket::hostFromAddress6:" ref="ae9d74d1cb4a5bb355b30d4192eba7c15" args="(struct sockaddr_in6 *pSockaddr6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (NSString *) hostFromAddress6: </td>
          <td></td>
          <td class="paramtype">(struct sockaddr_in6 *)&#160;</td>
          <td class="paramname"><em>pSockaddr6</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method param struct sockaddr_in6 returns NSString </p>

</div>
</div>
<a class="anchor" id="a3f41fe787e381c7af97783db95dad8d6"></a><!-- doxytag: member="GCDAsyncSocket::hostFromAddress:" ref="a3f41fe787e381c7af97783db95dad8d6" args="(NSData *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (NSString *) hostFromAddress: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>address</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method Gets the host from an address param <a class="el" href="class_n_s_data.html">NSData</a> returns NSString </p>

</div>
</div>
<a class="anchor" id="a2d422942c387bfaa9e65ac4eb9eba942"></a><!-- doxytag: member="GCDAsyncSocket::init" ref="a2d422942c387bfaa9e65ac4eb9eba942" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) init </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> uses the standard delegate paradigm, but executes all delegate callbacks on a given delegate dispatch queue. This allows for maximum concurrency, while at the same time providing easy thread safety.</p>
<p>You MUST set a delegate AND delegate dispatch queue before attempting to use the socket, or you will get an error.</p>
<p>The socket queue is optional. If you pass NULL, <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> will automatically create it's own socket queue.</p>
<p>If you choose to provide a socket queue, the socket queue must not be a concurrent queue.</p>
<p>The delegate queue and socket queue can optionally be the same.</p>
<p>Initialize the <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> This message initializes the receiver, setting the delegate at the same time. returns self (instance of <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a>) </p>

</div>
</div>
<a class="anchor" id="a2acc29ad9908180ac8897a2d1ace2d2c"></a><!-- doxytag: member="GCDAsyncSocket::initWithDelegate:delegateQueue:" ref="a2acc29ad9908180ac8897a2d1ace2d2c" args="(id aDelegate,[delegateQueue] dispatch_queue_t dq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithDelegate: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>aDelegate</em></td>
        </tr>
        <tr>
          <td class="paramkey">delegateQueue:</td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>dq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> with a delegate and delegate queue param dispatch_queue_t returns id (self)</p>
<p>Initialize the <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> with delegate and delegate queue This message initializes the receiver, setting the delegate at the same time.</p>
<p>param id param dispatch_queue_t returns self (instance of <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a>) </p>

</div>
</div>
<a class="anchor" id="a928f5f65021efe000a8fdb870dd2e7b0"></a><!-- doxytag: member="GCDAsyncSocket::initWithDelegate:delegateQueue:socketQueue:" ref="a928f5f65021efe000a8fdb870dd2e7b0" args="(id aDelegate,[delegateQueue] dispatch_queue_t dq,[socketQueue] dispatch_queue_t sq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithDelegate: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>aDelegate</em></td>
        </tr>
        <tr>
          <td class="paramkey">delegateQueue:</td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>dq</em></td>
        </tr>
        <tr>
          <td class="paramkey">socketQueue:</td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>sq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> with a delegate, delegate queue, and socket queue param id param dispatch_queue_t param dispatch_queue_t returns id</p>
<p>Initialize the <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> with delegate, delegate queue, and socket queue This message initializes the receiver, setting the delegate at the same time.</p>
<p>param id param dispatch_queue_t param dispatch_queue_t returns self (instance of <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a>) </p>

</div>
</div>
<a class="anchor" id="af1e9f7995ba07948f23cb441d14f7df3"></a><!-- doxytag: member="GCDAsyncSocket::initWithSocketQueue:" ref="af1e9f7995ba07948f23cb441d14f7df3" args="(dispatch_queue_t sq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithSocketQueue: </td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>sq</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> with a socket queue</p>
<p>param dispatch_queue_t returns id (self)</p>
<p>Initialize the <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> with a socket queue</p>
<p>param dispatch_queue_t returns self (instance of <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a>) </p>

</div>
</div>
<a class="anchor" id="a4142950e55bb0360f1fc5ca2487f29fb"></a><!-- doxytag: member="GCDAsyncSocket::isConnected" ref="a4142950e55bb0360f1fc5ca2487f29fb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isConnected </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns BOOL </p>

</div>
</div>
<a class="anchor" id="a10056a2b522dcef57f504152118e3e2e"></a><!-- doxytag: member="GCDAsyncSocket::isDisconnected" ref="a10056a2b522dcef57f504152118e3e2e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isDisconnected </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether the socket is disconnected or connected.</p>
<p>A disconnected socket may be recycled. That is, it can used again for connecting or listening.</p>
<p>If a socket is in the process of connecting, it may be neither disconnected nor connected. </p>

</div>
</div>
<a class="anchor" id="a601b053635887e0e806c6048a59b443f"></a><!-- doxytag: member="GCDAsyncSocket::isIPv4" ref="a601b053635887e0e806c6048a59b443f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isIPv4 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether the socket is IPv4 or IPv6. An accepting socket may be both. returns BOOL </p>

</div>
</div>
<a class="anchor" id="a4f1f326605ff3abefbf9647db91d3881"></a><!-- doxytag: member="GCDAsyncSocket::isIPv4Enabled" ref="a4f1f326605ff3abefbf9647db91d3881" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isIPv4Enabled </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>By default, both IPv4 and IPv6 are enabled.</p>
<p>For accepting incoming connections, this means <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> automatically supports both protocols, and can simulataneously accept incoming connections on either protocol.</p>
<p>For outgoing connections, this means <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> can connect to remote hosts running either protocol. If a DNS lookup returns only IPv4 results, <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> will automatically use IPv4. If a DNS lookup returns only IPv6 results, <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> will automatically use IPv6. If a DNS lookup returns both IPv4 and IPv6 results, the preferred protocol will be chosen. By default, the preferred protocol is IPv4, but may be configured as desired. Whether IP version 4 is enabled returns BOOL</p>
<p>Returns whether IP version 4 is enabled returns BOOL </p>

</div>
</div>
<a class="anchor" id="ac701a9ffe46759ed2e2e84817e3a881c"></a><!-- doxytag: member="GCDAsyncSocket::isIPv4PreferredOverIPv6" ref="ac701a9ffe46759ed2e2e84817e3a881c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isIPv4PreferredOverIPv6 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Whether IP version 4 protocol is preferred over IP version 6 protocol returns BOOL</p>
<p>Whether IP version 4 is preferred over IP version 6 returns BOOL </p>

</div>
</div>
<a class="anchor" id="afe8f125e89051b9795f392d967ce4736"></a><!-- doxytag: member="GCDAsyncSocket::isIPv6" ref="afe8f125e89051b9795f392d967ce4736" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isIPv6 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns BOOL </p>

</div>
</div>
<a class="anchor" id="a6cb6d0d972faae18e40acaad15736151"></a><!-- doxytag: member="GCDAsyncSocket::isIPv6Enabled" ref="a6cb6d0d972faae18e40acaad15736151" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isIPv6Enabled </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Whether IP version 6 protocol is enabled returns BOOL</p>
<p>Returns whether IP version 6 is enabled returns BOOL </p>

</div>
</div>
<a class="anchor" id="a3200e4bd391e47d8d54feb220cfd1322"></a><!-- doxytag: member="GCDAsyncSocket::LFData" ref="a3200e4bd391e47d8d54feb220cfd1322" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (<a class="el" href="class_n_s_data.html">NSData</a> *) LFData </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method returns <a class="el" href="class_n_s_data.html">NSData</a> </p>

</div>
</div>
<a class="anchor" id="a4729d86e82885f95ba75853da263480a"></a><!-- doxytag: member="GCDAsyncSocket::localAddress" ref="a4729d86e82885f95ba75853da263480a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="class_n_s_data.html">NSData</a> *) localAddress </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns <a class="el" href="class_n_s_data.html">NSData</a> </p>

</div>
</div>
<a class="anchor" id="a08877f86b6d2cb3e1dbb67f86300aba3"></a><!-- doxytag: member="GCDAsyncSocket::localHost" ref="a08877f86b6d2cb3e1dbb67f86300aba3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) localHost </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns NSString </p>

</div>
</div>
<a class="anchor" id="a39b5e0db29254bfc4f61ae32ef603d35"></a><!-- doxytag: member="GCDAsyncSocket::localHost4" ref="a39b5e0db29254bfc4f61ae32ef603d35" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) localHost4 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns NSString </p>

</div>
</div>
<a class="anchor" id="a51627ce6a95c2a549973f1fc5007e5ed"></a><!-- doxytag: member="GCDAsyncSocket::localHost6" ref="a51627ce6a95c2a549973f1fc5007e5ed" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) localHost6 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns NSString </p>

</div>
</div>
<a class="anchor" id="a0d4f19fd6b358a2cb8b30052e7a4497f"></a><!-- doxytag: member="GCDAsyncSocket::localHostFromSocket4:" ref="a0d4f19fd6b358a2cb8b30052e7a4497f" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) localHostFromSocket4: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns NSString </p>

</div>
</div>
<a class="anchor" id="abcfb7b8707d4b3a4934c53a080b8f279"></a><!-- doxytag: member="GCDAsyncSocket::localHostFromSocket6:" ref="abcfb7b8707d4b3a4934c53a080b8f279" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) localHostFromSocket6: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns NSString </p>

</div>
</div>
<a class="anchor" id="ae5fb325e175009929b7ef93e78879c9c"></a><!-- doxytag: member="GCDAsyncSocket::localPort" ref="ae5fb325e175009929b7ef93e78879c9c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) localPort </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns UInt16 </p>

</div>
</div>
<a class="anchor" id="ab01c7c0cac08d0264450e134f62092c6"></a><!-- doxytag: member="GCDAsyncSocket::localPort4" ref="ab01c7c0cac08d0264450e134f62092c6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) localPort4 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="a74aa01f42e06d4b9e3550b7aeb42b1f7"></a><!-- doxytag: member="GCDAsyncSocket::localPort6" ref="a74aa01f42e06d4b9e3550b7aeb42b1f7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) localPort6 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="a638322810b8824f3eb3aaee60e342a71"></a><!-- doxytag: member="GCDAsyncSocket::localPortFromSocket4:" ref="a638322810b8824f3eb3aaee60e342a71" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) localPortFromSocket4: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="af8551c92edaefdb1d2c2e2211788d368"></a><!-- doxytag: member="GCDAsyncSocket::localPortFromSocket6:" ref="af8551c92edaefdb1d2c2e2211788d368" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) localPortFromSocket6: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="a02c48caec85f0454705dfc06a3f5966e"></a><!-- doxytag: member="GCDAsyncSocket::lookup:didFail:" ref="a02c48caec85f0454705dfc06a3f5966e" args="(int aConnectIndex,[didFail] NSError *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) lookup: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>aConnectIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">didFail:</td>
          <td></td>
          <td class="paramtype">(NSError *)&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int param NSError </p>

</div>
</div>
<a class="anchor" id="a9bc3dca5cd675d47e43dee2447e477c5"></a><!-- doxytag: member="GCDAsyncSocket::lookup:didSucceedWithAddress4:address6:" ref="a9bc3dca5cd675d47e43dee2447e477c5" args="(int aConnectIndex,[didSucceedWithAddress4] NSData *address4,[address6] NSData *address6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) lookup: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>aConnectIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">didSucceedWithAddress4:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>address4</em></td>
        </tr>
        <tr>
          <td class="paramkey">address6:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>address6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int param <a class="el" href="class_n_s_data.html">NSData</a> param <a class="el" href="class_n_s_data.html">NSData</a> </p>

</div>
</div>
<a class="anchor" id="ae780c2624e6d78e92b738f43369870fc"></a><!-- doxytag: member="GCDAsyncSocket::lookup:host:port:" ref="ae780c2624e6d78e92b738f43369870fc" args="(int aConnectIndex,[host] NSString *host,[port] UInt16 port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) lookup: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>aConnectIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">host:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>host</em></td>
        </tr>
        <tr>
          <td class="paramkey">port:</td>
          <td></td>
          <td class="paramtype">(UInt16)&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int param NSString param UInt16 </p>

</div>
</div>
<a class="anchor" id="a120dd009e5510f9e808759134978974d"></a><!-- doxytag: member="GCDAsyncSocket::maybeClose" ref="a120dd009e5510f9e808759134978974d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) maybeClose </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if can close the connection </p>

</div>
</div>
<a class="anchor" id="abd37101a5cdbf6e1a99da06515da3413"></a><!-- doxytag: member="GCDAsyncSocket::maybeDequeueRead" ref="abd37101a5cdbf6e1a99da06515da3413" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) maybeDequeueRead </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Conditionally starts a new read.</p>
<p>It is called when:</p>
<ul>
<li>a user requests a read</li>
<li>after a read request has finished (to handle the next request)</li>
<li>immediately after the socket opens to handle any pending requests</li>
</ul>
<p>This method also handles auto-disconnect post read completion. </p>

</div>
</div>
<a class="anchor" id="a9aa34b22c10b7a8aa24d48c425386a78"></a><!-- doxytag: member="GCDAsyncSocket::maybeDequeueWrite" ref="a9aa34b22c10b7a8aa24d48c425386a78" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) maybeDequeueWrite </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Conditionally starts a new write.</p>
<p>It is called when:</p>
<ul>
<li>a user requests a write</li>
<li>after a write request has finished (to handle the next request)</li>
<li>immediately after the socket opens to handle any pending requests</li>
</ul>
<p>This method also handles auto-disconnect post read/write completion. </p>

</div>
</div>
<a class="anchor" id="a94a185938b550754fef77b4b888dc223"></a><!-- doxytag: member="GCDAsyncSocket::maybeStartTLS" ref="a94a185938b550754fef77b4b888dc223" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) maybeStartTLS </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Conditionally start trasport layer security </p>

</div>
</div>
<a class="anchor" id="adfa2a23e17778ac54c2cc6c100a66fac"></a><!-- doxytag: member="GCDAsyncSocket::otherError:" ref="adfa2a23e17778ac54c2cc6c100a66fac" args="(NSString *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSError *) otherError: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>msg</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param msg returns NSError </p>

</div>
</div>
<a class="anchor" id="ad05fe74acc7a045fe423023efeec5d47"></a><!-- doxytag: member="GCDAsyncSocket::performBlock:" ref="ad05fe74acc7a045fe423023efeec5d47" args="(dispatch_block_t block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) performBlock: </td>
          <td></td>
          <td class="paramtype">(dispatch_block_t)&#160;</td>
          <td class="paramname"><em>block</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>It's not thread-safe to access certain variables from outside the socket's internal queue.</p>
<p>For example, the socket file descriptor. File descriptors are simply integers which reference an index in the per-process file table. However, when one requests a new file descriptor (by opening a file or socket), the file descriptor returned is guaranteed to be the lowest numbered unused descriptor. So if we're not careful, the following could be possible:</p>
<ul>
<li>Thread A invokes a method which returns the socket's file descriptor.</li>
<li>The socket is closed via the socket's internal queue on thread B.</li>
<li>Thread C opens a file, and subsequently receives the file descriptor that was previously the socket's FD.</li>
<li>Thread A is now accessing/altering the file instead of the socket.</li>
</ul>
<p>In addition to this, other variables are not actually objects, and thus cannot be retained/released or even autoreleased. An example is the sslContext, of type SSLContextRef, which is actually a malloc'd struct.</p>
<p>Although there are internal variables that make it difficult to maintain thread-safety, it is important to provide access to these variables to ensure this class can be used in a wide array of environments. This method helps to accomplish this by invoking the current block on the socket's internal queue. The methods below can be invoked from within the block to access those generally thread-unsafe internal variables in a thread-safe manner. The given block will be invoked synchronously on the socket's internal queue.</p>
<p>If you save references to any protected variables and use them outside the block, you do so at your own peril. </p>

</div>
</div>
<a class="anchor" id="a66725f4718e4d77a2a2b06392a0d4b83"></a><!-- doxytag: member="GCDAsyncSocket::portFromAddress4:" ref="a66725f4718e4d77a2a2b06392a0d4b83" args="(struct sockaddr_in *pSockaddr4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (UInt16) portFromAddress4: </td>
          <td></td>
          <td class="paramtype">(struct sockaddr_in *)&#160;</td>
          <td class="paramname"><em>pSockaddr4</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method param struck sockaddr_in (IP version 4) returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="a36cd4cc75bd3e2fa740105e77b02ab23"></a><!-- doxytag: member="GCDAsyncSocket::portFromAddress6:" ref="a36cd4cc75bd3e2fa740105e77b02ab23" args="(struct sockaddr_in6 *pSockaddr6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (UInt16) portFromAddress6: </td>
          <td></td>
          <td class="paramtype">(struct sockaddr_in6 *)&#160;</td>
          <td class="paramname"><em>pSockaddr6</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method param struct sockaddr_in6 (IP version 6) returns UInt16 </p>

</div>
</div>
<a class="anchor" id="a1a8f7d6e4e4a498596ce839ba96b36ab"></a><!-- doxytag: member="GCDAsyncSocket::portFromAddress:" ref="a1a8f7d6e4e4a498596ce839ba96b36ab" args="(NSData *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (UInt16) portFromAddress: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>address</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method Get the port from an address param <a class="el" href="class_n_s_data.html">NSData</a> returns UInt16 </p>

</div>
</div>
<a class="anchor" id="a524f3cb12b54a67c51afb1b48c2b6e34"></a><!-- doxytag: member="GCDAsyncSocket::readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:" ref="a524f3cb12b54a67c51afb1b48c2b6e34" args="(NSData *data,[withTimeout] NSTimeInterval timeout,[buffer] NSMutableData *buffer,[bufferOffset] NSUInteger offset,[maxLength] NSUInteger length,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToData: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>data</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">buffer:</td>
          <td></td>
          <td class="paramtype">(NSMutableData *)&#160;</td>
          <td class="paramname"><em>buffer</em></td>
        </tr>
        <tr>
          <td class="paramkey">bufferOffset:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">maxLength:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>length</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads bytes until (and including) the passed "data" parameter, which acts as a separator. The bytes will be appended to the given byte buffer starting at the given offset. The given buffer will automatically be increased in size if needed.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. If the buffer if nil, a buffer will automatically be created for you.</p>
<p>If maxLength is zero, no length restriction is enforced. Otherwise if maxLength bytes are read without completing the read, it is treated similarly to a timeout - the socket is closed with a GCDAsyncSocketReadMaxedOutError. The read will complete successfully if exactly maxLength bytes are read and the given data is found at the end.</p>
<p>If you pass a maxLength parameter that is less than the length of the data parameter, the method will do nothing, and the delegate will not be called. If the bufferOffset is greater than the length of the given buffer, the method will do nothing, and the delegate will not be called.</p>
<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it. After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer. That is, it will reference the bytes that were appended to the given buffer.</p>
<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the "data" parameter. Note that this method is not character-set aware, so if a separator can occur naturally as part of the encoding for a character, the read will prematurely end. </p>

</div>
</div>
<a class="anchor" id="a24aefd40c4b1d2204bc871f96fc63868"></a><!-- doxytag: member="GCDAsyncSocket::readDataToData:withTimeout:buffer:bufferOffset:tag:" ref="a24aefd40c4b1d2204bc871f96fc63868" args="(NSData *data,[withTimeout] NSTimeInterval timeout,[buffer] NSMutableData *buffer,[bufferOffset] NSUInteger offset,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToData: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>data</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">buffer:</td>
          <td></td>
          <td class="paramtype">(NSMutableData *)&#160;</td>
          <td class="paramname"><em>buffer</em></td>
        </tr>
        <tr>
          <td class="paramkey">bufferOffset:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads bytes until (and including) the passed "data" parameter, which acts as a separator. The bytes will be appended to the given byte buffer starting at the given offset. The given buffer will automatically be increased in size if needed.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. If the buffer if nil, a buffer will automatically be created for you.</p>
<p>If the bufferOffset is greater than the length of the given buffer, the method will do nothing, and the delegate will not be called.</p>
<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it. After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer. That is, it will reference the bytes that were appended to the given buffer.</p>
<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the "data" parameter. Note that this method is not character-set aware, so if a separator can occur naturally as part of the encoding for a character, the read will prematurely end. </p>

</div>
</div>
<a class="anchor" id="a83c3c2b258aa829a9336e1a84ece3bb5"></a><!-- doxytag: member="GCDAsyncSocket::readDataToData:withTimeout:maxLength:tag:" ref="a83c3c2b258aa829a9336e1a84ece3bb5" args="(NSData *data,[withTimeout] NSTimeInterval timeout,[maxLength] NSUInteger length,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToData: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>data</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">maxLength:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>length</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads bytes until (and including) the passed "data" parameter, which acts as a separator.</p>
<p>If the timeout value is negative, the read operation will not use a timeout.</p>
<p>If maxLength is zero, no length restriction is enforced. Otherwise if maxLength bytes are read without completing the read, it is treated similarly to a timeout - the socket is closed with a GCDAsyncSocketReadMaxedOutError. The read will complete successfully if exactly maxLength bytes are read and the given data is found at the end.</p>
<p>If you pass nil or zero-length data as the "data" parameter, the method will do nothing, and the delegate will not be called. If you pass a maxLength parameter that is less than the length of the data parameter, the method will do nothing, and the delegate will not be called.</p>
<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the "data" parameter. Note that this method is not character-set aware, so if a separator can occur naturally as part of the encoding for a character, the read will prematurely end. </p>

</div>
</div>
<a class="anchor" id="ae24961705f14d5874f97ac86f98bd79a"></a><!-- doxytag: member="GCDAsyncSocket::readDataToData:withTimeout:tag:" ref="ae24961705f14d5874f97ac86f98bd79a" args="(NSData *data,[withTimeout] NSTimeInterval timeout,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToData: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>data</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads bytes until (and including) the passed "data" parameter, which acts as a separator.</p>
<p>If the timeout value is negative, the read operation will not use a timeout.</p>
<p>If you pass nil or zero-length data as the "data" parameter, the method will do nothing, and the delegate will not be called.</p>
<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the "data" parameter. Note that this method is not character-set aware, so if a separator can occur naturally as part of the encoding for a character, the read will prematurely end. </p>

</div>
</div>
<a class="anchor" id="a809c3ee372faddffea0ffbc13e2c42f5"></a><!-- doxytag: member="GCDAsyncSocket::readDataToLength:withTimeout:buffer:bufferOffset:tag:" ref="a809c3ee372faddffea0ffbc13e2c42f5" args="(NSUInteger length,[withTimeout] NSTimeInterval timeout,[buffer] NSMutableData *buffer,[bufferOffset] NSUInteger offset,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToLength: </td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>length</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">buffer:</td>
          <td></td>
          <td class="paramtype">(NSMutableData *)&#160;</td>
          <td class="paramname"><em>buffer</em></td>
        </tr>
        <tr>
          <td class="paramkey">bufferOffset:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the given number of bytes. The bytes will be appended to the given byte buffer starting at the given offset. The given buffer will automatically be increased in size if needed.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. If the buffer if nil, a buffer will automatically be created for you.</p>
<p>If the length is 0, this method does nothing and the delegate is not called. If the bufferOffset is greater than the length of the given buffer, the method will do nothing, and the delegate will not be called.</p>
<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it. After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer. That is, it will reference the bytes that were appended to the given buffer. </p>

</div>
</div>
<a class="anchor" id="a4bcf76fb9c6f6d4096ae557ffdc1704c"></a><!-- doxytag: member="GCDAsyncSocket::readDataToLength:withTimeout:tag:" ref="a4bcf76fb9c6f6d4096ae557ffdc1704c" args="(NSUInteger length,[withTimeout] NSTimeInterval timeout,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToLength: </td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>length</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the given number of bytes.</p>
<p>If the timeout value is negative, the read operation will not use a timeout.</p>
<p>If the length is 0, this method does nothing and the delegate is not called. </p>

</div>
</div>
<a class="anchor" id="a07f1d68ddd293188871327da6146d9d1"></a><!-- doxytag: member="GCDAsyncSocket::readDataWithTimeout:buffer:bufferOffset:maxLength:tag:" ref="a07f1d68ddd293188871327da6146d9d1" args="(NSTimeInterval timeout,[buffer] NSMutableData *buffer,[bufferOffset] NSUInteger offset,[maxLength] NSUInteger length,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataWithTimeout: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">buffer:</td>
          <td></td>
          <td class="paramtype">(NSMutableData *)&#160;</td>
          <td class="paramname"><em>buffer</em></td>
        </tr>
        <tr>
          <td class="paramkey">bufferOffset:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">maxLength:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>length</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the first available bytes that become available on the socket. The bytes will be appended to the given byte buffer starting at the given offset. The given buffer will automatically be increased in size if needed. A maximum of length bytes will be read.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. If the buffer if nil, a buffer will automatically be created for you. If maxLength is zero, no length restriction is enforced.</p>
<p>If the bufferOffset is greater than the length of the given buffer, the method will do nothing, and the delegate will not be called.</p>
<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it. After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer. That is, it will reference the bytes that were appended to the given buffer. </p>

</div>
</div>
<a class="anchor" id="a88357813a6f92a079332fb03948ef391"></a><!-- doxytag: member="GCDAsyncSocket::readDataWithTimeout:buffer:bufferOffset:tag:" ref="a88357813a6f92a079332fb03948ef391" args="(NSTimeInterval timeout,[buffer] NSMutableData *buffer,[bufferOffset] NSUInteger offset,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataWithTimeout: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">buffer:</td>
          <td></td>
          <td class="paramtype">(NSMutableData *)&#160;</td>
          <td class="paramname"><em>buffer</em></td>
        </tr>
        <tr>
          <td class="paramkey">bufferOffset:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the first available bytes that become available on the socket. The bytes will be appended to the given byte buffer starting at the given offset. The given buffer will automatically be increased in size if needed.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. If the buffer if nil, the socket will create a buffer for you.</p>
<p>If the bufferOffset is greater than the length of the given buffer, the method will do nothing, and the delegate will not be called.</p>
<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it. After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer. That is, it will reference the bytes that were appended to the given buffer. </p>

</div>
</div>
<a class="anchor" id="a19d9cbf0ad11001fec6d0d7356c29afc"></a><!-- doxytag: member="GCDAsyncSocket::readDataWithTimeout:tag:" ref="a19d9cbf0ad11001fec6d0d7356c29afc" args="(NSTimeInterval timeout,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataWithTimeout: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the first available bytes that become available on the socket.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. </p>

</div>
</div>
<a class="anchor" id="a2b5918fe0055f396fdc0d4d970f28ccb"></a><!-- doxytag: member="GCDAsyncSocket::resumeReadSource" ref="a2b5918fe0055f396fdc0d4d970f28ccb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) resumeReadSource </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resumes the read source </p>

</div>
</div>
<a class="anchor" id="a2aaead7c26870c68de2da294c75766cf"></a><!-- doxytag: member="GCDAsyncSocket::resumeWriteSource" ref="a2aaead7c26870c68de2da294c75766cf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) resumeWriteSource </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resumes the write source </p>

</div>
</div>
<a class="anchor" id="a9cc5e539079bc42d46ec33dd43bbed53"></a><!-- doxytag: member="GCDAsyncSocket::setAutoDisconnectOnClosedReadStream:" ref="a9cc5e539079bc42d46ec33dd43bbed53" args="(BOOL flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setAutoDisconnectOnClosedReadStream: </td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>flag</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the flag for whether automatically disconnecting upon the closing of a read stream param BOOL</p>
<p>Sets the flag for whether to automatically disconnect upon closing the read stream param BOOL </p>

</div>
</div>
<a class="anchor" id="aed81eac721c788ddd2d77531422df31a"></a><!-- doxytag: member="GCDAsyncSocket::setDelegate:" ref="aed81eac721c788ddd2d77531422df31a" args="(id delegate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setDelegate: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>newDelegate</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the delegate param id </p>

</div>
</div>
<a class="anchor" id="ad50a28ce05e978e4f77d0d5e5a43b377"></a><!-- doxytag: member="GCDAsyncSocket::setDelegate:delegateQueue:" ref="ad50a28ce05e978e4f77d0d5e5a43b377" args="(id delegate,[delegateQueue] dispatch_queue_t delegateQueue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setDelegate: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>newDelegate</em></td>
        </tr>
        <tr>
          <td class="paramkey">delegateQueue:</td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>newDelegateQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the delegate and delegate queue param id param dispatch_queue_t</p>
<p>Sets the delegate and delegate queue param id param dispatch_queue_t </p>

</div>
</div>
<a class="anchor" id="afb2ef66b28a4ea5c0bfc943c51d2053d"></a><!-- doxytag: member="GCDAsyncSocket::setDelegateQueue:" ref="afb2ef66b28a4ea5c0bfc943c51d2053d" args="(dispatch_queue_t delegateQueue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setDelegateQueue: </td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>newDelegateQueue</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the delegate queue param dispatch_queue_t</p>
<p>Sets the delegate queue param dispatch_queue_t </p>

</div>
</div>
<a class="anchor" id="a6e9dab1dec79b1dc931f246de95d138e"></a><!-- doxytag: member="GCDAsyncSocket::setIPv4Enabled:" ref="a6e9dab1dec79b1dc931f246de95d138e" args="(BOOL flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setIPv4Enabled: </td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>flag</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the flag for whether IP version 4 protocol is enabled param BOOL</p>
<p>Sets the flag to enable IP version 4 param BOOL </p>

</div>
</div>
<a class="anchor" id="ac6941a96608c7dd8be4accdf5b8b7688"></a><!-- doxytag: member="GCDAsyncSocket::setIPv6Enabled:" ref="ac6941a96608c7dd8be4accdf5b8b7688" args="(BOOL flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setIPv6Enabled: </td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>flag</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the flag for whether IP version 6 protocol is enabled param BOOL</p>
<p>Sets the flag to enable IP version 6 param BOOL </p>

</div>
</div>
<a class="anchor" id="aab5301b56fde5d73120f7e80a2fdfc87"></a><!-- doxytag: member="GCDAsyncSocket::setPreferIPv4OverIPv6:" ref="aab5301b56fde5d73120f7e80a2fdfc87" args="(BOOL flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setPreferIPv4OverIPv6: </td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>flag</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the flag for whether IP version 4 protocol is preferred over IP version 6 param BOOL</p>
<p>Set the flag for whether IP version 4 is preferred over IP version 6 param BOOL </p>

</div>
</div>
<a class="anchor" id="a7494f8b50cb3c1e23914c46d71620522"></a><!-- doxytag: member="GCDAsyncSocket::setupReadAndWriteSourcesForNewlyConnectedSocket:" ref="a7494f8b50cb3c1e23914c46d71620522" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setupReadAndWriteSourcesForNewlyConnectedSocket: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Setup the read and write source for a newly connected socket param int </p>

</div>
</div>
<a class="anchor" id="a6add59c82678059664c7b2c0f376ae23"></a><!-- doxytag: member="GCDAsyncSocket::setupReadTimerWithTimeout:" ref="a6add59c82678059664c7b2c0f376ae23" args="(NSTimeInterval timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setupReadTimerWithTimeout: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Setup the readtime with a time interaval param NSTimeInterval </p>

</div>
</div>
<a class="anchor" id="abfef9c29a14799f680bd9fe94a119be6"></a><!-- doxytag: member="GCDAsyncSocket::setupWriteTimerWithTimeout:" ref="abfef9c29a14799f680bd9fe94a119be6" args="(NSTimeInterval timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setupWriteTimerWithTimeout: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param NSTimeInterval </p>

</div>
</div>
<a class="anchor" id="a26ea92d533af7d0533e0ff390b7c748e"></a><!-- doxytag: member="GCDAsyncSocket::setUserData:" ref="a26ea92d533af7d0533e0ff390b7c748e" args="(id arbitraryUserData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setUserData: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>arbitraryUserData</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param id</p>
<p>Sets userData param id </p>

</div>
</div>
<a class="anchor" id="ac1d5a563d5230b3fb2969133a9f2f705"></a><!-- doxytag: member="GCDAsyncSocket::socket4FD" ref="ac1d5a563d5230b3fb2969133a9f2f705" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (int) socket4FD </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns int </p>

</div>
</div>
<a class="anchor" id="a4c06877731887f66a9bc476b61fcbf7a"></a><!-- doxytag: member="GCDAsyncSocket::socket6FD" ref="a4c06877731887f66a9bc476b61fcbf7a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (int) socket6FD </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns int </p>

</div>
</div>
<a class="anchor" id="a2ac1c7744b1711cb15944966ba20f1c6"></a><!-- doxytag: member="GCDAsyncSocket::socketFD" ref="a2ac1c7744b1711cb15944966ba20f1c6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (int) socketFD </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These methods are only available from within the context of a performBlock: invocation. See the documentation for the performBlock: method above.</p>
<p>Provides access to the socket's file descriptor(s). If the socket is a server socket (is accepting incoming connections), it might actually have multiple internal socket file descriptors - one for IPv4 and one for IPv6. </p>

</div>
</div>
<a class="anchor" id="a8a89890a7da7749e9563640cb8b343a3"></a><!-- doxytag: member="GCDAsyncSocket::sslContext" ref="a8a89890a7da7749e9563640cb8b343a3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (SSLContextRef) sslContext </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is only available from within the context of a performBlock: invocation. See the documentation for the performBlock: method above.</p>
<p>Provides access to the socket's SSLContext, if SSL/TLS has been started on the socket. </p>

</div>
</div>
<a class="anchor" id="a889ef4cccbf90f858e5698d9030f6efe"></a><!-- doxytag: member="GCDAsyncSocket::startConnectTimeout:" ref="a889ef4cccbf90f858e5698d9030f6efe" args="(NSTimeInterval timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) startConnectTimeout: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param NSTimeInterval </p>

</div>
</div>
<a class="anchor" id="a70408047b819b6e8063140281b69a67c"></a><!-- doxytag: member="GCDAsyncSocket::startTLS:" ref="a70408047b819b6e8063140281b69a67c" args="(NSDictionary *tlsSettings)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) startTLS: </td>
          <td></td>
          <td class="paramtype">(NSDictionary *)&#160;</td>
          <td class="paramname"><em>tlsSettings</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Secures the connection using SSL/TLS.</p>
<p>This method may be called at any time, and the TLS handshake will occur after all pending reads and writes are finished. This allows one the option of sending a protocol dependent StartTLS message, and queuing the upgrade to TLS at the same time, without having to wait for the write to finish. Any reads or writes scheduled after this method is called will occur over the secured connection.</p>
<p>The possible keys and values for the TLS settings are well documented. Some possible keys are:</p>
<ul>
<li>kCFStreamSSLLevel</li>
<li>kCFStreamSSLAllowsExpiredCertificates</li>
<li>kCFStreamSSLAllowsExpiredRoots</li>
<li>kCFStreamSSLAllowsAnyRoot</li>
<li>kCFStreamSSLValidatesCertificateChain</li>
<li>kCFStreamSSLPeerName</li>
<li>kCFStreamSSLCertificates</li>
<li>kCFStreamSSLIsServer</li>
</ul>
<p>Please refer to Apple's documentation for associated values, as well as other possible keys.</p>
<p>If you pass in nil or an empty dictionary, the default settings will be used.</p>
<p>The default settings will check to make sure the remote party's certificate is signed by a trusted 3rd party certificate agency (e.g. verisign) and that the certificate is not expired. However it will not verify the name on the certificate unless you give it a name to verify against via the kCFStreamSSLPeerName key. The security implications of this are important to understand. Imagine you are attempting to create a secure connection to MySecureServer.com, but your socket gets directed to MaliciousServer.com because of a hacked DNS server. If you simply use the default settings, and MaliciousServer.com has a valid certificate, the default settings will not detect any problems since the certificate is valid. To properly secure your connection in this particular scenario you should set the kCFStreamSSLPeerName property to "MySecureServer.com". If you do not know the peer name of the remote host in advance (for example, you're not sure if it will be "domain.com" or "www.domain.com"), then you can use the default settings to validate the certificate, and then use the X509Certificate class to verify the issuer after the socket has been secured. The X509Certificate class is part of the CocoaAsyncSocket open source project. </p>

</div>
</div>
<a class="anchor" id="a6d3843736b927a2103e4d54ccdd407ac"></a><!-- doxytag: member="GCDAsyncSocket::suspendReadSource" ref="a6d3843736b927a2103e4d54ccdd407ac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) suspendReadSource </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Suspends the read source </p>

</div>
</div>
<a class="anchor" id="a2ecfc37c4758e86238b1b71967ed8734"></a><!-- doxytag: member="GCDAsyncSocket::suspendWriteSource" ref="a2ecfc37c4758e86238b1b71967ed8734" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) suspendWriteSource </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Suspends the write source </p>

</div>
</div>
<a class="anchor" id="ac3f33527738b5dfd19520a6ef3992801"></a><!-- doxytag: member="GCDAsyncSocket::synchronouslySetDelegate:" ref="ac3f33527738b5dfd19520a6ef3992801" args="(id delegate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) synchronouslySetDelegate: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>newDelegate</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Synchronously sets the delegate param id</p>
<p>Set the delegate as a new delegate param id </p>

</div>
</div>
<a class="anchor" id="aa73b3285e4aba9a2c17b3e86b7e1b8ee"></a><!-- doxytag: member="GCDAsyncSocket::synchronouslySetDelegate:delegateQueue:" ref="aa73b3285e4aba9a2c17b3e86b7e1b8ee" args="(id delegate,[delegateQueue] dispatch_queue_t delegateQueue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) synchronouslySetDelegate: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>newDelegate</em></td>
        </tr>
        <tr>
          <td class="paramkey">delegateQueue:</td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>newDelegateQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Synchronously set the delegate and delegate queue param id param dispatch_queue_t</p>
<p>Set delegate for delgate queuue param id param dispatch_queue_t </p>

</div>
</div>
<a class="anchor" id="ae24331d1128f067ab6a10cc2325f3524"></a><!-- doxytag: member="GCDAsyncSocket::synchronouslySetDelegateQueue:" ref="ae24331d1128f067ab6a10cc2325f3524" args="(dispatch_queue_t delegateQueue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) synchronouslySetDelegateQueue: </td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>newDelegateQueue</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param dispatch_queue_t</p>
<p>Sets the delegate queue param dispatch_queue_t </p>

</div>
</div>
<a class="anchor" id="a478519828098f75eb1831de787e21ad3"></a><!-- doxytag: member="GCDAsyncSocket::userData" ref="a478519828098f75eb1831de787e21ad3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) <a class="el" href="interface_g_c_d_async_socket.html#a56949c539124f9b2d07ca1fe2f5f1302">userData</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>User data allows you to associate arbitrary information with the socket. This data is not used internally by socket in any way. returns id </p>

</div>
</div>
<a class="anchor" id="ac10926913689fda565d495dd53ce6b16"></a><!-- doxytag: member="GCDAsyncSocket::writeData:withTimeout:tag:" ref="ac10926913689fda565d495dd53ce6b16" args="(NSData *data,[withTimeout] NSTimeInterval timeout,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) writeData: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>data</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes data to the socket, and calls the delegate when finished.</p>
<p>If you pass in nil or zero-length data, this method does nothing and the delegate will not be called. If the timeout value is negative, the write operation will not use a timeout. </p>

</div>
</div>
<a class="anchor" id="a0ec17715f642213548c05050cbbdfeb2"></a><!-- doxytag: member="GCDAsyncSocket::ZeroData" ref="a0ec17715f642213548c05050cbbdfeb2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (<a class="el" href="class_n_s_data.html">NSData</a> *) ZeroData </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method returns <a class="el" href="class_n_s_data.html">NSData</a> </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a21b567384add155d21ae42dd5f38434f"></a><!-- doxytag: member="GCDAsyncSocket::delegate" ref="a21b567384add155d21ae42dd5f38434f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) <a class="el" href="interface_g_c_d_async_socket.html#a21b567384add155d21ae42dd5f38434f">delegate</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the delegate off the socketQueue returns id </p>

</div>
</div>
<a class="anchor" id="ad94468240917f346e161380a61ebc56d"></a><!-- doxytag: member="GCDAsyncSocket::delegateQueue" ref="ad94468240917f346e161380a61ebc56d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (dispatch_queue_t) <a class="el" href="interface_g_c_d_async_socket.html#ad94468240917f346e161380a61ebc56d">delegateQueue</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the delegateQueue returns dispatch_queue_t </p>

</div>
</div>
<a class="anchor" id="a56949c539124f9b2d07ca1fe2f5f1302"></a><!-- doxytag: member="GCDAsyncSocket::userData" ref="a56949c539124f9b2d07ca1fe2f5f1302" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) <a class="el" href="interface_g_c_d_async_socket.html#a56949c539124f9b2d07ca1fe2f5f1302">userData</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the userData User data allows you to associate arbitrary information with the socket. This data is not used internally by socket in any way. returns id </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/willrubel/IOS-Streaming-Browser/IOS-Streaming-Browser/<a class="el" href="_g_c_d_async_socket_8h_source.html">GCDAsyncSocket.h</a></li>
<li>/Users/willrubel/IOS-Streaming-Browser/IOS-Streaming-Browser/GCDAsyncSocket.m</li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a>      </li>
      <li class="footer">Generated on Fri Jun 3 2011 14:25:03 for IOS Streaming Browser by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Properties</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
