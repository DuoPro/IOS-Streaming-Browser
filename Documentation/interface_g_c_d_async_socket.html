<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>IOS Streaming Browser: GCDAsyncSocket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Icon.png"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">IOS Streaming Browser&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">An IOS streaming browser to stream the display to others or to a projector</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('interface_g_c_d_async_socket.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>GCDAsyncSocket Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="GCDAsyncSocket" -->
<p><code>#import &lt;<a class="el" href="">GCDAsyncSocket.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for GCDAsyncSocket:</div>
<div class="dyncontent">
<div class="center"><img src="interface_g_c_d_async_socket__coll__graph.png" border="0" usemap="#_g_c_d_async_socket_coll__map" alt="Collaboration graph"/></div>
<map name="_g_c_d_async_socket_coll__map" id="_g_c_d_async_socket_coll__map">
<area shape="rect" id="node2" href="interface_g_c_d_async_write_packet.html" title="GCDAsyncWritePacket" alt="" coords="154,101,333,129"/><area shape="rect" id="node4" href="class_n_s_data.html" title="NSData" alt="" coords="207,6,279,34"/><area shape="rect" id="node7" href="interface_g_c_d_async_read_packet.html" title="GCDAsyncReadPacket" alt="" coords="357,101,533,129"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a4213bb26f5207ee3f402fe463badc691">init</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aaa7a544e6a86f4df110ff353e4a10597">initWithSocketQueue:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a504b2a0981de8ea8758effb60245973e">initWithDelegate:delegateQueue:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a75fe279d42a5c8078f8bac4d953c81a8">initWithDelegate:delegateQueue:socketQueue:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a6c98e239b6ba279cfc95c64db9de555c">delegate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a5147f10c2f5e0df2682c4ce073138ac8">setDelegate:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aa5625ed5c76085530b96dc6c5e2839d1">synchronouslySetDelegate:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(dispatch_queue_t)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ad8e601f3e3e4ec791f9a7741ff12aec5">delegateQueue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ad2a40c88499dd4d26e1ee23e51619dd2">setDelegateQueue:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ababced98cdedb94928d4e96b86005f8f">synchronouslySetDelegateQueue:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ac861d6b5813a114fba01d00fecbeb36f">getDelegate:delegateQueue:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a7e25f164690499ebb02ad52944ebd4f5">setDelegate:delegateQueue:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a16ada359e981e7021f834a467cd47558">synchronouslySetDelegate:delegateQueue:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ad6699479eef6e61e54c6edfcb17a75ed">autoDisconnectOnClosedReadStream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#adc2fecde2f4d460a7e8d010d9cf01300">setAutoDisconnectOnClosedReadStream:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a9fd367a3576e58665df01f6a376621eb">isIPv4Enabled</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a5a64cbec31543316e5318fb1a5caf393">setIPv4Enabled:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a86e92e8be0617f9ec2ae403d5ff3a04e">isIPv6Enabled</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a41d137c83f5004f0fb38422b15270d7d">setIPv6Enabled:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ac8a98d880cd216a59a118b9243f9896d">isIPv4PreferredOverIPv6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a73908d258ad70bf185c3ba61fd0a80ab">setPreferIPv4OverIPv6:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ab46069d6ffbcb6a0bb1eae5aaaafe94a">userData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ad64373d841eb1408af17341cf27067f4">setUserData:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ac015445dd1feaaa3b0a07ef63b4d806f">acceptOnPort:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a14076bc135ae30b77f93cf5338796f1d">acceptOnInterface:port:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a3d9205d70242e9e2547148c6b05b397e">connectToHost:onPort:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a72977694b5f8374592b423a66b1e23a3">connectToHost:onPort:withTimeout:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ac69dc181fa49533b8cc041d59d38d8f4">connectToHost:onPort:viaInterface:withTimeout:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2e1af5ef7a3e1ee37613dddb7c0e0617">connectToAddress:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ae023e135c607e4ad8a7dd86a1be7efe2">connectToAddress:withTimeout:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a12de200ef677c49f7b013b1646453dcb">connectToAddress:viaInterface:withTimeout:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a960705de531a20389fb29928d43258c3">disconnect</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a9c49760a3286a595f3cdc0702733baed">disconnectAfterReading</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a40c9570c2e696d6c48347024fa1f8b5c">disconnectAfterWriting</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a31e39568995cdc85c4feb5a76c645d5f">disconnectAfterReadingAndWriting</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a72a57ce3f39762161947846bbe03a621">isDisconnected</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ad3515f7fe2b8ed2b9e14233cf7ede0bc">isConnected</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a918b8d6a97c1f0a2cd938cc61d3ff353">connectedHost</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2337a76e32d4e2836888e58723977b7e">connectedPort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a544fa124053aea063a8be148cf24d491">localHost</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a1b6cdcf368d68e9ffb28e359e5c23ce8">localPort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aa9aa24b40191e606b428588285deb640">connectedAddress</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a279be33392f836041828ae18ed4678a3">localAddress</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a7f1734034c9aa5b62cfeb69f203729e3">isIPv4</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aa009ac699bce64f1d087a0eafeb2a371">isIPv6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a58e63ca19338d5e052ad36e2e64ec585">readDataWithTimeout:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a289b8c694675c219c9726385c90e8068">readDataWithTimeout:buffer:bufferOffset:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a9ec74c83f6f87dfd8980c98deae38640">readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2acf5d5f2c006ea0e14a97b8802bdf7d">readDataToLength:withTimeout:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a7f742375bde66d11c43a478835c04805">readDataToLength:withTimeout:buffer:bufferOffset:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a3a92e46de7766b3ac649f3d68d370599">readDataToData:withTimeout:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a8782b6bf0862529a8efad865b20eb55f">readDataToData:withTimeout:buffer:bufferOffset:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#abfb0d880d5853402309d80151c19ef85">readDataToData:withTimeout:maxLength:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2a8c215b2b1baee60b831081a5e302ac">readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a7f85c2e3c19bbe013c180b4668a28fc2">writeData:withTimeout:tag:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aec4d670add3f78c669277990d7b48056">startTLS:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a0f9e5a401b98234ed1522174f1ef5d33">performBlock:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(int)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ad7cd01612683e0994e7ef2fadf77952e">socketFD</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(int)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2b9c119ffa6ff18321572f26a759b9ed">socket4FD</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(int)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ad6120d297c599aff1e50bd2ce917e3ad">socket6FD</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(SSLContextRef)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a09f53a1bc824259a55ff249183111beb">sslContext</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#adf2b811edc6945d075c61bfdc82370ac">doAccept:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a6a35d03945525a87faa9428bfd284fb8">startConnectTimeout:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a26caa9d94af387148d3a2ddf0612d9d7">endConnectTimeout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a87f777ed73194b8aa4698bb117b2ddf6">doConnectTimeout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ada876adf7aa6dd0e85eac5dd88d0487a">lookup:host:port:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a324f120c3c25c99a68d462e398e310ee">lookup:didSucceedWithAddress4:address6:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2b0440d4004fff8ccc8cecd08b499b67">lookup:didFail:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a69a249a85f05de648a8c15e02f4bdbac">connectWithAddress4:address6:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a82eeef89347f1fec7f2281e6f22dd372">didConnect:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a9915204aa99bbcd91a8c50c2df4f3955">didNotConnect:error:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ad734635ca5a8a6b9dc3524f85dea7676">closeWithError:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a5ae591df94fc66ccb85cbb6565368bca">close</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a9d104e16cf86945653536862fbb11b20">maybeClose</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSError *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a68a1ef5d6a9bf59c0a45c7b49ea83300">badConfigError:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSError *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#acc3f0992aaeecba6f824d68a94ee0f7d">badParamError:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSError *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a25576f025696077083ffab579188d000">gaiError:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSError *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a2e46b6e45efdada29eb5b26883dc8e5c">errnoError</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSError *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ab64eb8fd614b2f2502d3e5be1b449a76">errnoErrorWithReason:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSError *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a1294a06a0c9caae7f540e7c3e929db5a">connectTimeoutError</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSError *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a5d930a6904127fd8b0c5cc85dfc5bb87">otherError:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a251b0e63e8b762f4dbff6b1030ff4c08">connectedHost4</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a509c5882f4d418f674663d34ed2564a8">connectedHost6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a5077576479de3bca27bdf4309d124a73">connectedPort4</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a51e4e6f41718b27141d455bd7e31cc77">connectedPort6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a4702ea42737d8732eff7d37bb661d1fb">localHost4</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ac5a80b83d64f10ebc037ecbe91002347">localHost6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a11c3a22df8764878ede33514c4e6e81e">localPort4</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a21bd5ee77206fb4d740cfe6e2e546d57">localPort6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aced5a582b84e44861311717cc0caae40">connectedHostFromSocket4:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#afc53b55b0ced1e5147bef160fb75ebb1">connectedHostFromSocket6:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aa56826b9d5cfadb6049db1f369e8b0cf">connectedPortFromSocket4:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a9c757a331da5341b2d3a9d7c06cf5b94">connectedPortFromSocket6:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a1c7469573dd259dd7758c752638bb6b0">localHostFromSocket4:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ac37c12af87e892233a18bddf93b317e7">localHostFromSocket6:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a30b4b1539bf92f40c06b773216450c46">localPortFromSocket4:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ad5635ba68ed384dcfd5728fb456ee37d">localPortFromSocket6:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a872bbd6498010a0c5ce983d91e35fd51">getInterfaceAddress4:address6:fromDescription:port:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a3508a47866b5711e375a7154243f645c">setupReadAndWriteSourcesForNewlyConnectedSocket:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a02f78d565bb4c1527f8b278bf926821f">suspendReadSource</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a31e716bfc42afec3ea1588b2d875dc93">resumeReadSource</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#acb866c203e932f8028d08be4d3cea0b8">suspendWriteSource</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a6f47f83f8897b1d29eee31935e659641">resumeWriteSource</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a71ded98e88b1001fd651951a35654734">maybeDequeueRead</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#ac699644e023a07acac06ec297f436bef">doReadData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a6ce5da2611c33dd622ee93777ddcbe84">doReadEOF</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aff46e99a04ace9e7556da4a90155a7ab">completeCurrentRead</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a7ddda9613a043ee3044c154ed877e750">endCurrentRead</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a6a86a4d4cfe0fe4b8132b0f71e151173">setupReadTimerWithTimeout:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a758d098ce32744465e14d24e35763f73">doReadTimeout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a5c9a838de41540f52252b4822f2ec49a">doReadTimeoutWithExtension:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a185ab7cd6a129e604a01195589db6ea7">maybeDequeueWrite</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#abd9a68b37d6d84c80a138213d54f15e1">doWriteData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a1fed06588167a9defd9b6633c0606612">completeCurrentWrite</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a468b9f90a54b420746956c45daa48d52">endCurrentWrite</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a1a0e01352480012cdfd6e2b0ab48acfb">setupWriteTimerWithTimeout:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a806b0275df7c7bb03bf599f711e1429a">doWriteTimeout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#af01b86e26b678e1f9cf8ad8330a407fe">doWriteTimeoutWithExtension:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#a1bc43cb9e0ad8f6e03562838e3a61c9e">maybeStartTLS</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_g_c_d_async_socket.html#aacd220af818626d82e1886970428f8b0">continueSSLHandshake</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#ad25cbed4327e1a30c369f5367af185f0">hostFromAddress:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#a3a18b9c4019805df06935f1b2c0ba0e4">portFromAddress:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#adad43bd80dfcbfa004d0732e090544bd">getHost:port:fromAddress:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#a6d7dfcd7967c0e16b86ae64e5579b709">CRLFData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#adde78bb75988b51f5c403daebcd91f99">CRData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#a9f80c130183f3fa0f324c7505127ab77">LFData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#aa051f54bdd6c087a6b4a51c799dbc68b">ZeroData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#a78b15d688675f086c5a84378ee23f79c">hostFromAddress4:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#aae67418d3932685622e2ff08adbf8f3e">hostFromAddress6:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#abb46f6848a640f3546c885001065184b">portFromAddress4:</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(UInt16)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_g_c_d_async_socket.html#ac731b6646d8ac41864b5e9add9440fcc">portFromAddress6:</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UInt16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a0c12680bebc888c6b3a967c074c1b53b">flags</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UInt16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a8d9332fcd23523b1e2520b8765577423">delegate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dispatch_queue_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a97158c52f2a4011454b4eb3ee369a8a1">delegateQueue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a5e9a52b6037bb7ca77d20ff6cdf009e7">socket4FD</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a76b50c6289ef8990165376846c312fc2">socket6FD</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#adead8a55f9eb7ea6b017928b8f07ba88">connectIndex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_n_s_data.html">NSData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#ad95ce3c72099d8264f7d11b80086577f">connectInterface4</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_n_s_data.html">NSData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#ae1dcf5b9961daf9d6a2d3554cd35793c">connectInterface6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dispatch_queue_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dispatch_source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a0258b7b16069bcc876876f11f5bfbf00">accept4Source</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dispatch_source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a003699eaada0bca7f6036a850e9ded20">accept6Source</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dispatch_source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a2878c7d9cca5a4b7a557358db8559abd">connectTimer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dispatch_source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a54a3d7f734424b2d249a1a246021ab7f">readSource</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dispatch_source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#aa43b40a19fac92685a75405df0cdaccf">writeSource</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dispatch_source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a24e3b4a8ae9be3aad363801c2f92f75e">readTimer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dispatch_source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a0f701534080cce80a769478c6063ddbc">writeTimer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NSMutableArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a93d45803a1d4682aaefb278b0a2bd93f">readQueue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NSMutableArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a1ad8da0672218827b7a1a4abbdf1f34d">writeQueue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_g_c_d_async_read_packet.html">GCDAsyncReadPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#ac6eeee8bb60215eea067cdfcb844f557">currentRead</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_g_c_d_async_write_packet.html">GCDAsyncWritePacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a4b3234a5bb213a8af4cf4b3e3f2548e5">currentWrite</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a608e58eacfd78e9223f9a34eb3af30d9">socketFDBytesAvailable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NSMutableData *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a2c92583ab159460443b3d9b73b2b4156">partialReadBuffer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SSLContextRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#abc0b34177c702ee1e5f0e10c4cd6f8a7">sslContext</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NSMutableData *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#adb68739cb718c58bd309456690e52aca">sslReadBuffer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#a87060da8aee33ea041edcf0490262651">sslWriteCachedLength</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_g_c_d_async_socket.html#aaed3930744ea96721de0752032e8f541">userData</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="#L51">51</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a14076bc135ae30b77f93cf5338796f1d"></a><!-- doxytag: member="GCDAsyncSocket::acceptOnInterface:port:error:" ref="a14076bc135ae30b77f93cf5338796f1d" args="(NSString *interface,[port] UInt16 port,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) acceptOnInterface: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>interface</em></td>
        </tr>
        <tr>
          <td class="paramkey">port:</td>
          <td></td>
          <td class="paramtype">(UInt16)&#160;</td>
          <td class="paramname"><em>port</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is the same as acceptOnPort:error: with the additional option of specifying which interface to listen on.</p>
<p>For example, you could specify that the socket should only accept connections over ethernet, and not other interfaces such as wifi.</p>
<p>The interface may be specified by name (e.g. "en1" or "lo0") or by IP address (e.g. "192.168.4.34"). You may also use the special strings "localhost" or "loopback" to specify that the socket only accept connections from the local machine.</p>
<p>You can see the list of interfaces via the command line utility "ifconfig", or programmatically via the getifaddrs() function.</p>
<p>To accept connections on any interface pass nil, or simply use the acceptOnPort:error: method.</p>
<p>Whether accept connection on interface and port param NSString param UInt16 returns BOOL </p>

<p>Definition at line <a class="el" href="#L2250">2250</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                         :(NSString *)interface port:(UInt16)port error:(NSError **)errPtr
{
        <a class="code" href="_g_c_d_async_socket_8m.html#a282aedf4001558d418c496d375aa5491">LogTrace</a>();
        
    <span class="comment">// Gets the result from the block</span>
        __block BOOL result = YES;
        __block NSError *err = nil;
        
        <span class="comment">// CreateSocket Block</span>
        <span class="comment">// This block will be invoked within the dispatch block below.</span>
        <span class="comment">// defines a block of createSocket type with accepts int (domain) and NSData (interface address) as arguements</span>
    
        int(^createSocket)(int, <a class="code" href="class_n_s_data.html">NSData</a>*) = ^<span class="keywordtype">int</span> (<span class="keywordtype">int</span> domain, <a class="code" href="class_n_s_data.html">NSData</a> *interfaceAddr) {
                
        <span class="comment">// creates an endpoint for communication and returns a descriptor</span>
                <span class="keywordtype">int</span> <a class="code" href="interface_g_c_d_async_socket.html#ad7cd01612683e0994e7ef2fadf77952e">socketFD</a> = socket(domain, SOCK_STREAM, 0);
                
        
                <span class="keywordflow">if</span> (socketFD == <a class="code" href="_g_c_d_async_socket_8m.html#aff67b96affb34fbb2dace4386402202c">SOCKET_NULL</a>)
                {
                        NSString *reason = <span class="stringliteral">@&quot;Error in socket() function&quot;</span>;
                        err = [[<span class="keyword">self</span> errnoErrorWithReason:reason] retain];
                        
                        <span class="keywordflow">return</span> <a class="code" href="_g_c_d_async_socket_8m.html#aff67b96affb34fbb2dace4386402202c">SOCKET_NULL</a>;
                }
                
        
                <span class="keywordtype">int</span> status;
                
                <span class="comment">// Set socket options</span>
<span class="comment"></span>        <span class="comment">// file control</span>
        <span class="comment">// F_SETFL sets the descriptor flags</span>
        <span class="comment">// O_NONBLOCK - Non-blocking I/O; if no data is available to a read</span>
        <span class="comment">// call, or if a write operation would block, the read or</span>
        <span class="comment">// write call returns -1 with the error EAGAIN.</span>
                status = fcntl(socketFD, F_SETFL, O_NONBLOCK);
                <span class="keywordflow">if</span> (status == -1)
                {
                        NSString *reason = <span class="stringliteral">@&quot;Error enabling non-blocking IO on socket (fcntl)&quot;</span>;
                        err = [[<span class="keyword">self</span> errnoErrorWithReason:reason] retain];
                        
                        <a class="code" href="interface_g_c_d_async_socket.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>(socketFD);
                        <span class="keywordflow">return</span> <a class="code" href="_g_c_d_async_socket_8m.html#aff67b96affb34fbb2dace4386402202c">SOCKET_NULL</a>;
                }
        
        <span class="comment">// If reusing sockets</span>
                <span class="keywordtype">int</span> reuseOn = 1;
        
        <span class="comment">// Set the options on a socket</span>
        <span class="comment">// SO_REUSEADDR indicates that the rules used in validating</span>
        <span class="comment">// addresses supplied in bind(2) call should allow reuse of </span>
        <span class="comment">// local addresses</span>
                status = setsockopt(socketFD, SOL_SOCKET, SO_REUSEADDR, &amp;reuseOn, <span class="keyword">sizeof</span>(reuseOn));
        
        <span class="comment">// Check if could set the socket options</span>
                <span class="keywordflow">if</span> (status == -1)
                {
                        NSString *reason = <span class="stringliteral">@&quot;Error enabling address reuse (setsockopt)&quot;</span>;
                        err = [[<span class="keyword">self</span> errnoErrorWithReason:reason] retain];
                        
            <span class="comment">// Close the socket</span>
                        <a class="code" href="interface_g_c_d_async_socket.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>(socketFD);
                        <span class="keywordflow">return</span> <a class="code" href="_g_c_d_async_socket_8m.html#aff67b96affb34fbb2dace4386402202c">SOCKET_NULL</a>;
                }
                
                <span class="comment">// Bind socket</span>
<span class="comment"></span>        
        
        <span class="comment">// bind the socket to a interface</span>
                status = bind(socketFD, (<span class="keyword">struct</span> sockaddr *)[interfaceAddr bytes], (socklen_t)[interfaceAddr length]);
        
        <span class="comment">// If could not bind socket</span>
                <span class="keywordflow">if</span> (status == -1)
                {
                        NSString *reason = <span class="stringliteral">@&quot;Error in bind() function&quot;</span>;
                        err = [[<span class="keyword">self</span> errnoErrorWithReason:reason] retain];
                        
            <span class="comment">// Close the socket</span>
                        <a class="code" href="interface_g_c_d_async_socket.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>(socketFD);
                        <span class="keywordflow">return</span> <a class="code" href="_g_c_d_async_socket_8m.html#aff67b96affb34fbb2dace4386402202c">SOCKET_NULL</a>;
                }
                
                <span class="comment">// Listen on the socket</span>
<span class="comment"></span>        
        <span class="comment">// listen for connections on a socket</span>
                status = listen(socketFD, 1024);
        
        <span class="comment">// Check if we can listen to a connection on a socket</span>
                <span class="keywordflow">if</span> (status == -1)
                {
                        NSString *reason = <span class="stringliteral">@&quot;Error in listen() function&quot;</span>;
                        err = [[<span class="keyword">self</span> errnoErrorWithReason:reason] retain];
                        
            <span class="comment">// Close the socket</span>
                        <a class="code" href="interface_g_c_d_async_socket.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>(socketFD);
                        <span class="keywordflow">return</span> <a class="code" href="_g_c_d_async_socket_8m.html#aff67b96affb34fbb2dace4386402202c">SOCKET_NULL</a>;
                }
                
                <span class="keywordflow">return</span> <a class="code" href="interface_g_c_d_async_socket.html#ad7cd01612683e0994e7ef2fadf77952e">socketFD</a>;
        };
        
        <span class="comment">// Create dispatch block and run on socketQueue</span>
        
    
        dispatch_block_t block = ^{

                NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
                
                <span class="keywordflow">if</span> (<a class="code" href="interface_g_c_d_async_socket.html#a6c98e239b6ba279cfc95c64db9de555c">delegate</a> == nil) <span class="comment">// Must have delegate set</span>
                {
                        result = NO;
                        
                        NSString *msg = <span class="stringliteral">@&quot;Attempting to accept without a delegate. Set a delegate first.&quot;</span>;
                        err = [[<span class="keyword">self</span> badConfigError:msg] retain];
                        
                        [pool drain];
                        <a class="code" href="_g_c_d_async_socket_8m.html#aa442f26da6b58a622aec5270956e88e9">return_from_block</a>;
                }
                
                <span class="keywordflow">if</span> (<a class="code" href="interface_g_c_d_async_socket.html#ad8e601f3e3e4ec791f9a7741ff12aec5">delegateQueue</a> == NULL) <span class="comment">// Must have delegate queue set</span>
                {
                        result = NO;
                        
                        NSString *msg = <span class="stringliteral">@&quot;Attempting to accept without a delegate queue. Set a delegate queue first.&quot;</span>;
                        err = [[<span class="keyword">self</span> badConfigError:msg] retain];
                        
                        [pool drain];
                        <a class="code" href="_g_c_d_async_socket_8m.html#aa442f26da6b58a622aec5270956e88e9">return_from_block</a>;
                }
                
        <span class="comment">// Whether IP version 4 protocol is disabled</span>
                BOOL isIPv4Disabled = (<a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> &amp; <a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059a5e1715b3fa60f2fe05eaf896dfee0cf8" title="If set, IPv4 is disabled.">kIPv4Disabled</a>) ? YES : NO;
        
        <span class="comment">// Whether IP version 6 protocol is disabled</span>
                BOOL isIPv6Disabled = (<a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> &amp; <a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059a94e72322e8d8380318632317bc451eee" title="If set, IPv6 is disabled.">kIPv6Disabled</a>) ? YES : NO;
                
        <span class="comment">// If both IP version 4 and IP version 6 are disabled</span>
                <span class="keywordflow">if</span> (isIPv4Disabled &amp;&amp; isIPv6Disabled) <span class="comment">// Must have IPv4 or IPv6 enabled</span>
                {
                        result = NO;
                        
                        NSString *msg = <span class="stringliteral">@&quot;Both IPv4 and IPv6 have been disabled. Must enable at least one protocol first.&quot;</span>;
                        err = [[<span class="keyword">self</span> badConfigError:msg] retain];
                        
                        [pool drain];
                        <a class="code" href="_g_c_d_async_socket_8m.html#aa442f26da6b58a622aec5270956e88e9">return_from_block</a>;
                }
                
        
                <span class="keywordflow">if</span> (![<span class="keyword">self</span> <a class="code" href="interface_g_c_d_async_socket.html#a72a57ce3f39762161947846bbe03a621">isDisconnected</a>]) <span class="comment">// Must be disconnected</span>
                {
                        result = NO;
                        
                        NSString *msg = <span class="stringliteral">@&quot;Attempting to accept while connected or accepting connections. Disconnect first.&quot;</span>;
                        err = [[<span class="keyword">self</span> badConfigError:msg] retain];
                        
                        [pool drain];
                        <a class="code" href="_g_c_d_async_socket_8m.html#aa442f26da6b58a622aec5270956e88e9">return_from_block</a>;
                }
                
                <span class="comment">// Clear queues (spurious read/write requests post disconnect)</span>
                [readQueue removeAllObjects];
                [writeQueue removeAllObjects];
                
        
                <span class="comment">// Resolve interface from description</span>
                
                <a class="code" href="class_n_s_data.html">NSData</a> *interface4 = nil;
                <a class="code" href="class_n_s_data.html">NSData</a> *interface6 = nil;
                
        <span class="comment">// Get the interface address from an interface description and port</span>
                [<span class="keyword">self</span> getInterfaceAddress4:&amp;interface4 address6:&amp;interface6 fromDescription:interface port:port];
                
        
                <span class="keywordflow">if</span> ((interface4 == nil) &amp;&amp; (interface6 == nil))
                {
                        result = NO;
                        
                        NSString *msg = <span class="stringliteral">@&quot;Unknown interface. Specify valid interface by name (e.g. \&quot;</span>en1\<span class="stringliteral">&quot;) or IP address.&quot;</span>;
                        err = [[<span class="keyword">self</span> badParamError:msg] retain];
                        
                        [pool drain];
                        <a class="code" href="_g_c_d_async_socket_8m.html#aa442f26da6b58a622aec5270956e88e9">return_from_block</a>;
                }
                
                <span class="keywordflow">if</span> (isIPv4Disabled &amp;&amp; (interface6 == nil))
                {
                        result = NO;
                        
                        NSString *msg = <span class="stringliteral">@&quot;IPv4 has been disabled and specified interface doesn&#39;t support IPv6.&quot;</span>;
                        err = [[<span class="keyword">self</span> badParamError:msg] retain];
                        
                        [pool drain];
                        <a class="code" href="_g_c_d_async_socket_8m.html#aa442f26da6b58a622aec5270956e88e9">return_from_block</a>;
                }
                
                <span class="keywordflow">if</span> (isIPv6Disabled &amp;&amp; (interface4 == nil))
                {
                        result = NO;
                        
                        NSString *msg = <span class="stringliteral">@&quot;IPv6 has been disabled and specified interface doesn&#39;t support IPv4.&quot;</span>;
                        err = [[<span class="keyword">self</span> badParamError:msg] retain];
                        
                        [pool drain];
                        <a class="code" href="_g_c_d_async_socket_8m.html#aa442f26da6b58a622aec5270956e88e9">return_from_block</a>;
                }
                
        <span class="comment">// Whether IP version 4 protocol is enabled</span>
                BOOL enableIPv4 = !isIPv4Disabled &amp;&amp; (interface4 != nil);
        
        <span class="comment">// Whether IP version 6 protocol is enabled</span>
                BOOL enableIPv6 = !isIPv6Disabled &amp;&amp; (interface6 != nil);
                
                <span class="comment">// Create sockets, configure, bind, and listen</span>
<span class="comment"></span>        
        <span class="comment">// If IP version 4 protocol is enabled</span>
                <span class="keywordflow">if</span> (enableIPv4)
                {
                        <a class="code" href="_g_c_d_async_socket_8m.html#aca071706c0170f9944b310449356d2f8">LogVerbose</a>(<span class="stringliteral">@&quot;Creating IPv4 socket&quot;</span>);
            
            <span class="comment">// Create an internal socket</span>
                        <a class="code" href="interface_g_c_d_async_socket.html#a2b9c119ffa6ff18321572f26a759b9ed">socket4FD</a> = createSocket(AF_INET, interface4);
                        
            <span class="comment">// If there is not an IP version 4 socket file descriptor</span>
                        <span class="keywordflow">if</span> (<a class="code" href="interface_g_c_d_async_socket.html#a2b9c119ffa6ff18321572f26a759b9ed">socket4FD</a> == <a class="code" href="_g_c_d_async_socket_8m.html#aff67b96affb34fbb2dace4386402202c">SOCKET_NULL</a>)
                        {
                                result = NO;
                                
                                [pool drain];
                                <a class="code" href="_g_c_d_async_socket_8m.html#aa442f26da6b58a622aec5270956e88e9">return_from_block</a>;
                        }
                }
                
        <span class="comment">// If IP version 6 protocol is enabled</span>
                <span class="keywordflow">if</span> (enableIPv6)
                {
                        <a class="code" href="_g_c_d_async_socket_8m.html#aca071706c0170f9944b310449356d2f8">LogVerbose</a>(<span class="stringliteral">@&quot;Creating IPv6 socket&quot;</span>);
                        
            <span class="comment">// If IP version 4 protocol is enabled but the port is zero</span>
                        <span class="keywordflow">if</span> (enableIPv4 &amp;&amp; (port == 0))
                        {
                                <span class="comment">// No specific port was specified, so we allowed the OS to pick an available port for us.</span>
                                <span class="comment">// Now we need to make sure the IPv6 socket listens on the same port as the IPv4 socket.</span>
                                
                                <span class="keyword">struct </span>sockaddr_in6 *addr6 = (<span class="keyword">struct </span>sockaddr_in6 *)[interface6 bytes];
                
                <span class="comment">// Converts the local port from host to network byte order</span>
                                addr6-&gt;sin6_port = htons([<span class="keyword">self</span> <a class="code" href="interface_g_c_d_async_socket.html#a11c3a22df8764878ede33514c4e6e81e">localPort4</a>]);
                        }
                        
            <span class="comment">// Create an internal socket</span>
                        <a class="code" href="interface_g_c_d_async_socket.html#ad6120d297c599aff1e50bd2ce917e3ad">socket6FD</a> = createSocket(AF_INET6, interface6);
                        
            <span class="comment">// If there is not an IP version 6 file descriptor</span>
                        <span class="keywordflow">if</span> (<a class="code" href="interface_g_c_d_async_socket.html#ad6120d297c599aff1e50bd2ce917e3ad">socket6FD</a> == <a class="code" href="_g_c_d_async_socket_8m.html#aff67b96affb34fbb2dace4386402202c">SOCKET_NULL</a>)
                        {
                                result = NO;
                                
                <span class="comment">// If the IP version 4 socket is not null</span>
                                <span class="keywordflow">if</span> (<a class="code" href="interface_g_c_d_async_socket.html#a2b9c119ffa6ff18321572f26a759b9ed">socket4FD</a> != <a class="code" href="_g_c_d_async_socket_8m.html#aff67b96affb34fbb2dace4386402202c">SOCKET_NULL</a>)
                                {
                                        <a class="code" href="interface_g_c_d_async_socket.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>(<a class="code" href="interface_g_c_d_async_socket.html#a2b9c119ffa6ff18321572f26a759b9ed">socket4FD</a>);
                                }
                                
                                [pool drain];
                                <a class="code" href="_g_c_d_async_socket_8m.html#aa442f26da6b58a622aec5270956e88e9">return_from_block</a>;
                        }
                }
                
                <span class="comment">// Create accept sources</span>
<span class="comment"></span>        
        <span class="comment">// If IP version 4 protocol is enabled</span>
                <span class="keywordflow">if</span> (enableIPv4)
                {
            <span class="comment">// Creates a read source on the socketQueue</span>
                        <a class="code" href="interface_g_c_d_async_socket.html#a0258b7b16069bcc876876f11f5bfbf00">accept4Source</a> = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, <a class="code" href="interface_g_c_d_async_socket.html#a2b9c119ffa6ff18321572f26a759b9ed">socket4FD</a>, 0, <a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>);
                        
            
                        <span class="keywordtype">int</span> socketFD = <a class="code" href="interface_g_c_d_async_socket.html#a2b9c119ffa6ff18321572f26a759b9ed">socket4FD</a>;
            
            <span class="comment">// Dispatch sources are used to automatically submit event handler blocks to dispatch queues in response to external events.</span>
                        dispatch_source_t acceptSource = <a class="code" href="interface_g_c_d_async_socket.html#a0258b7b16069bcc876876f11f5bfbf00">accept4Source</a>;
                        
            <span class="comment">// Sets the event handler block for the accept4Source</span>
                        dispatch_source_set_event_handler(<a class="code" href="interface_g_c_d_async_socket.html#a0258b7b16069bcc876876f11f5bfbf00">accept4Source</a>, ^{
                
                                NSAutoreleasePool *eventPool = [[NSAutoreleasePool alloc] init];
                                
                                <a class="code" href="_g_c_d_async_socket_8m.html#aca071706c0170f9944b310449356d2f8">LogVerbose</a>(<span class="stringliteral">@&quot;event4Block&quot;</span>);
                                
                <span class="comment">// Value is 0 to 2,147,483,647</span>
                                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 0;
                
                <span class="comment">// Gets the number of pending connections to the server</span>
                <span class="comment">// Value is 0 to 2,147,483,647</span>
                                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> numPendingConnections = dispatch_source_get_data(acceptSource);
                                
                                <a class="code" href="_g_c_d_async_socket_8m.html#aca071706c0170f9944b310449356d2f8">LogVerbose</a>(<span class="stringliteral">@&quot;numPendingConnections: %lu&quot;</span>, numPendingConnections);
                                
                <span class="comment">// While accepting for parent socket file description and number of pending connections is greater than i</span>
                                <span class="keywordflow">while</span> ([<span class="keyword">self</span> doAccept:socketFD] &amp;&amp; (++i &lt; numPendingConnections));
                                
                                [eventPool drain];
                        }); <span class="comment">// END OF BLOCK</span>
                        
            
            <span class="comment">// Sets the cancellation handler block for the accept4Source</span>
                        dispatch_source_set_cancel_handler(<a class="code" href="interface_g_c_d_async_socket.html#a0258b7b16069bcc876876f11f5bfbf00">accept4Source</a>, ^{
                                
                                <a class="code" href="_g_c_d_async_socket_8m.html#aca071706c0170f9944b310449356d2f8">LogVerbose</a>(<span class="stringliteral">@&quot;dispatch_release(accept4Source)&quot;</span>);
                                dispatch_release(acceptSource);
                                
                                <a class="code" href="_g_c_d_async_socket_8m.html#aca071706c0170f9944b310449356d2f8">LogVerbose</a>(<span class="stringliteral">@&quot;close(socket4FD)&quot;</span>);
                                <a class="code" href="interface_g_c_d_async_socket.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>(socketFD);
                        }); <span class="comment">// END OF BLOCK</span>
                        
            
                        <a class="code" href="_g_c_d_async_socket_8m.html#aca071706c0170f9944b310449356d2f8">LogVerbose</a>(<span class="stringliteral">@&quot;dispatch_resume(accept4Source)&quot;</span>);
            
            <span class="comment">// Resume accepting IP version 4 connections</span>
                        dispatch_resume(<a class="code" href="interface_g_c_d_async_socket.html#a0258b7b16069bcc876876f11f5bfbf00">accept4Source</a>);  
                }
                
        <span class="comment">// If IP version 6 protocol is being utilized</span>
                <span class="keywordflow">if</span> (enableIPv6)
                {
            <span class="comment">// Dispatch sources are used to automatically submit event</span>
            <span class="comment">// handler blocks to dispatch queues in response to external </span>
            <span class="comment">// events.</span>
                        <a class="code" href="interface_g_c_d_async_socket.html#a003699eaada0bca7f6036a850e9ded20">accept6Source</a> = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, <a class="code" href="interface_g_c_d_async_socket.html#ad6120d297c599aff1e50bd2ce917e3ad">socket6FD</a>, 0, <a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>);
                        
            
                        <span class="keywordtype">int</span> socketFD = <a class="code" href="interface_g_c_d_async_socket.html#ad6120d297c599aff1e50bd2ce917e3ad">socket6FD</a>;
                        dispatch_source_t acceptSource = <a class="code" href="interface_g_c_d_async_socket.html#a003699eaada0bca7f6036a850e9ded20">accept6Source</a>;
                        
            
            <span class="comment">// Sets the event handler block for the accept6Source</span>
                        dispatch_source_set_event_handler(<a class="code" href="interface_g_c_d_async_socket.html#a003699eaada0bca7f6036a850e9ded20">accept6Source</a>, ^{

                                NSAutoreleasePool *eventPool = [[NSAutoreleasePool alloc] init];
                                
                                <a class="code" href="_g_c_d_async_socket_8m.html#aca071706c0170f9944b310449356d2f8">LogVerbose</a>(<span class="stringliteral">@&quot;event6Block&quot;</span>);
                                
                <span class="comment">// Value is 0 to 2,147,483,647</span>
                                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 0;
                
                <span class="comment">// Value is 0 to 2,147,483,647</span>
                                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> numPendingConnections = dispatch_source_get_data(acceptSource);
                                
                                <a class="code" href="_g_c_d_async_socket_8m.html#aca071706c0170f9944b310449356d2f8">LogVerbose</a>(<span class="stringliteral">@&quot;numPendingConnections: %lu&quot;</span>, numPendingConnections);
                                
                                <span class="keywordflow">while</span> ([<span class="keyword">self</span> doAccept:socketFD] &amp;&amp; (++i &lt; numPendingConnections));
                                
                                [eventPool drain];
                        }); <span class="comment">// END OF BLOCK</span>
                        
            
            <span class="comment">// Sets the cancellation handler block for the accept6Source</span>
                        dispatch_source_set_cancel_handler(<a class="code" href="interface_g_c_d_async_socket.html#a003699eaada0bca7f6036a850e9ded20">accept6Source</a>, ^{
                                
                                <a class="code" href="_g_c_d_async_socket_8m.html#aca071706c0170f9944b310449356d2f8">LogVerbose</a>(<span class="stringliteral">@&quot;dispatch_release(accept6Source)&quot;</span>);
                                dispatch_release(acceptSource);
                                
                                <a class="code" href="_g_c_d_async_socket_8m.html#aca071706c0170f9944b310449356d2f8">LogVerbose</a>(<span class="stringliteral">@&quot;close(socket6FD)&quot;</span>);
                                <a class="code" href="interface_g_c_d_async_socket.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>(socketFD);
                        }); <span class="comment">// END OF BLOCK</span>
                        
                        <a class="code" href="_g_c_d_async_socket_8m.html#aca071706c0170f9944b310449356d2f8">LogVerbose</a>(<span class="stringliteral">@&quot;dispatch_resume(accept6Source)&quot;</span>);
            
            <span class="comment">// Resume accepting IP version 6 connections</span>
                        dispatch_resume(<a class="code" href="interface_g_c_d_async_socket.html#a003699eaada0bca7f6036a850e9ded20">accept6Source</a>); 
                }
                
        <span class="comment">// If set, socket has been started (accepting/connecting)</span>
                <a class="code" href="interface_g_c_d_async_socket.html#a0c12680bebc888c6b3a967c074c1b53b">flags</a> |= <a class="code" href="_g_c_d_async_socket_8m.html#a3e7a047f26e53ddc6874fe6857ce98dbaf6203a46bd5f0e669a1943ec69511375" title="If set, socket has been started (accepting/connecting)">kSocketStarted</a>;
                [pool drain];
        };
        
    <span class="comment">// Returns the queue on which the currently executing block is running.</span>
    <span class="comment">// In this case, check if the socketQueue is currently running the block</span>
        <span class="keywordflow">if</span> (dispatch_get_current_queue() == <a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>)
    {
                block();  <span class="comment">// executes block on the socketQueue</span>
        }<span class="keywordflow">else</span>{
        
        <span class="comment">// Dispatches block for asynchronous execution on the socketQueue</span>
                dispatch_sync(<a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>, block);
    }
    
    
        <span class="keywordflow">if</span> (result == NO)
        {
                <a class="code" href="_g_c_d_async_socket_8m.html#ad35ed5f6028942a25f4c405df8c01eaf">LogInfo</a>(<span class="stringliteral">@&quot;Error in accept: %@&quot;</span>, err);
                
                <span class="keywordflow">if</span> (errPtr)
        {
                        *errPtr = [err autorelease];
            
                }<span class="keywordflow">else</span>{
            
                        [err release];
        }
        }
        
        <span class="keywordflow">return</span> result;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac015445dd1feaaa3b0a07ef63b4d806f"></a><!-- doxytag: member="GCDAsyncSocket::acceptOnPort:error:" ref="ac015445dd1feaaa3b0a07ef63b4d806f" args="(UInt16 port,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) acceptOnPort: </td>
          <td></td>
          <td class="paramtype">(UInt16)&#160;</td>
          <td class="paramname"><em>port</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tells the socket to begin listening and accepting connections on the given port.</p>
<p>When a connection is accepted, a new instance of <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> will be spawned to handle it, and the socket:didAcceptNewSocket: delegate method will be invoked.</p>
<p>The socket will listen on all available interfaces (e.g. wifi, ethernet, etc) param (UInt16) port param NSError returns BOOL</p>
<p>Whether accept connection on a port (listen socket) port - A port number at which the receiver should accept connections. errPtr - The address of an NSError object pointer. In the event of an error, the pointer will be set to the NSError object describing the error</p>
<p>param UInt16 param NSError returns BOOL </p>

<p>Definition at line <a class="el" href="#L2239">2239</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                    :(UInt16)port error:(NSError **)errPtr
{
        <span class="keywordflow">return</span> [<span class="keyword">self</span> acceptOnInterface:nil port:port error:errPtr];
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad6699479eef6e61e54c6edfcb17a75ed"></a><!-- doxytag: member="GCDAsyncSocket::autoDisconnectOnClosedReadStream" ref="ad6699479eef6e61e54c6edfcb17a75ed" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) autoDisconnectOnClosedReadStream </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Traditionally sockets are not closed until the conversation is over. However, it is technically possible for the remote endpoint to close its write stream. Our socket would then be notified that there is no more data to be read, but our socket would still be writeable and the remote endpoint could continue to receive our data.</p>
<p>The argument for this confusing functionality stems from the idea that a client could shut down its write stream after sending a request to the server, thus notifying the server there are to be no further requests. In practice, however, this technique did little to help server developers.</p>
<p>To make matters worse, from a TCP perspective there is no way to tell the difference from a read stream close and a full socket close. They both result in the TCP stack receiving a FIN packet. The only way to tell is by continuing to write to the socket. If it was only a read stream close, then writes will continue to work. Otherwise an error will be occur shortly (when the remote end sends us a RST (reset) packet).</p>
<p>In addition to the technical challenges and confusion, many high level socket/stream API's provide no support for dealing with the problem. If the read stream is closed, the API immediately declares the socket to be closed, and shuts down the write stream as well. In fact, this is what Apple's CFStream API does. It might sound like poor design at first, but in fact it simplifies development.</p>
<p>The vast majority of the time if the read stream is closed it's because the remote endpoint closed its socket. Thus it actually makes sense to close the socket at this point. And in fact this is what most networking developers want and expect to happen. However, if you are writing a server that interacts with a plethora of clients, you might encounter a client that uses the discouraged technique of shutting down its write stream. If this is the case, you can set this property to NO, and make use of the socketDidCloseReadStream delegate method.</p>
<p>The default value is YES. Whether automatically disconnecting upon the closing of a read stream returns BOOL</p>
<p>Whether to automatically disconnect upon closing the read stream returns BOOL </p>

<p>Definition at line <a class="el" href="#L1922">1922</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="comment">// Note: YES means kAllowHalfDuplexConnection is OFF</span>
        
    <span class="comment">// Returns the queue on which the currently executing block is running.</span>
    <span class="comment">// In this case, check if the socketQueue is currently running the block</span>
        <span class="keywordflow">if</span> (dispatch_get_current_queue() == <a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>)
        {
                <span class="keywordflow">return</span> ((<a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> &amp; <a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059ab4ef22464cc0e8c0c575e94595dcb5bc" title="If set, the socket will stay open even if the read stream closes.">kAllowHalfDuplexConnection</a>) == 0);
        }
        <span class="keywordflow">else</span> <span class="comment">// if the current queue is not the socketQueue</span>
        {
        <span class="comment">// Gets the result from the block</span>
                __block BOOL result;
                
        <span class="comment">//  Submits a block for synchronous execution on a dispatch queue.</span>
                dispatch_sync(<a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>, ^{
                        result = ((<a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> &amp; <a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059ab4ef22464cc0e8c0c575e94595dcb5bc" title="If set, the socket will stay open even if the read stream closes.">kAllowHalfDuplexConnection</a>) == 0);
                }); <span class="comment">// END OF BLOCK</span>
                
                <span class="keywordflow">return</span> result;
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a68a1ef5d6a9bf59c0a45c7b49ea83300"></a><!-- doxytag: member="GCDAsyncSocket::badConfigError:" ref="a68a1ef5d6a9bf59c0a45c7b49ea83300" args="(NSString *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSError *) badConfigError: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>msg</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param msg returns NSError </p>

</div>
</div>
<a class="anchor" id="acc3f0992aaeecba6f824d68a94ee0f7d"></a><!-- doxytag: member="GCDAsyncSocket::badParamError:" ref="acc3f0992aaeecba6f824d68a94ee0f7d" args="(NSString *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSError *) badParamError: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>msg</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param msg returns NSError </p>

</div>
</div>
<a class="anchor" id="a5ae591df94fc66ccb85cbb6565368bca"></a><!-- doxytag: member="GCDAsyncSocket::close" ref="a5ae591df94fc66ccb85cbb6565368bca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) close </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close the connection </p>

</div>
</div>
<a class="anchor" id="ad734635ca5a8a6b9dc3524f85dea7676"></a><!-- doxytag: member="GCDAsyncSocket::closeWithError:" ref="ad734635ca5a8a6b9dc3524f85dea7676" args="(NSError *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) closeWithError: </td>
          <td></td>
          <td class="paramtype">(NSError *)&#160;</td>
          <td class="paramname"><em>error</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param NSError </p>

</div>
</div>
<a class="anchor" id="aff46e99a04ace9e7556da4a90155a7ab"></a><!-- doxytag: member="GCDAsyncSocket::completeCurrentRead" ref="aff46e99a04ace9e7556da4a90155a7ab" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) completeCurrentRead </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Complete the current read </p>

</div>
</div>
<a class="anchor" id="a1fed06588167a9defd9b6633c0606612"></a><!-- doxytag: member="GCDAsyncSocket::completeCurrentWrite" ref="a1fed06588167a9defd9b6633c0606612" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) completeCurrentWrite </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Completes the current write </p>

</div>
</div>
<a class="anchor" id="aa9aa24b40191e606b428588285deb640"></a><!-- doxytag: member="GCDAsyncSocket::connectedAddress" ref="aa9aa24b40191e606b428588285deb640" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="class_n_s_data.html">NSData</a> *) connectedAddress </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the local or remote address to which this socket is connected, specified as a sockaddr structure wrapped in a <a class="el" href="class_n_s_data.html">NSData</a> object.</p>
<p>See also the connectedHost, connectedPort, localHost and localPort methods.</p>
<p>returns <a class="el" href="class_n_s_data.html">NSData</a> </p>

</div>
</div>
<a class="anchor" id="a918b8d6a97c1f0a2cd938cc61d3ff353"></a><!-- doxytag: member="GCDAsyncSocket::connectedHost" ref="a918b8d6a97c1f0a2cd938cc61d3ff353" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) connectedHost </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected. The host will be an IP address. </p>

</div>
</div>
<a class="anchor" id="a251b0e63e8b762f4dbff6b1030ff4c08"></a><!-- doxytag: member="GCDAsyncSocket::connectedHost4" ref="a251b0e63e8b762f4dbff6b1030ff4c08" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) connectedHost4 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns NSString </p>

</div>
</div>
<a class="anchor" id="a509c5882f4d418f674663d34ed2564a8"></a><!-- doxytag: member="GCDAsyncSocket::connectedHost6" ref="a509c5882f4d418f674663d34ed2564a8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) connectedHost6 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns NSString </p>

</div>
</div>
<a class="anchor" id="aced5a582b84e44861311717cc0caae40"></a><!-- doxytag: member="GCDAsyncSocket::connectedHostFromSocket4:" ref="aced5a582b84e44861311717cc0caae40" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) connectedHostFromSocket4: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns NSString </p>

</div>
</div>
<a class="anchor" id="afc53b55b0ced1e5147bef160fb75ebb1"></a><!-- doxytag: member="GCDAsyncSocket::connectedHostFromSocket6:" ref="afc53b55b0ced1e5147bef160fb75ebb1" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) connectedHostFromSocket6: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns NSString </p>

</div>
</div>
<a class="anchor" id="a2337a76e32d4e2836888e58723977b7e"></a><!-- doxytag: member="GCDAsyncSocket::connectedPort" ref="a2337a76e32d4e2836888e58723977b7e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) connectedPort </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns UInt16 </p>

</div>
</div>
<a class="anchor" id="a5077576479de3bca27bdf4309d124a73"></a><!-- doxytag: member="GCDAsyncSocket::connectedPort4" ref="a5077576479de3bca27bdf4309d124a73" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) connectedPort4 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="a51e4e6f41718b27141d455bd7e31cc77"></a><!-- doxytag: member="GCDAsyncSocket::connectedPort6" ref="a51e4e6f41718b27141d455bd7e31cc77" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) connectedPort6 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="aa56826b9d5cfadb6049db1f369e8b0cf"></a><!-- doxytag: member="GCDAsyncSocket::connectedPortFromSocket4:" ref="aa56826b9d5cfadb6049db1f369e8b0cf" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) connectedPortFromSocket4: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="a9c757a331da5341b2d3a9d7c06cf5b94"></a><!-- doxytag: member="GCDAsyncSocket::connectedPortFromSocket6:" ref="a9c757a331da5341b2d3a9d7c06cf5b94" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) connectedPortFromSocket6: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="a1294a06a0c9caae7f540e7c3e929db5a"></a><!-- doxytag: member="GCDAsyncSocket::connectTimeoutError" ref="a1294a06a0c9caae7f540e7c3e929db5a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSError *) connectTimeoutError </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns NSError </p>

</div>
</div>
<a class="anchor" id="a2e1af5ef7a3e1ee37613dddb7c0e0617"></a><!-- doxytag: member="GCDAsyncSocket::connectToAddress:error:" ref="a2e1af5ef7a3e1ee37613dddb7c0e0617" args="(NSData *remoteAddr,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToAddress: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>remoteAddr</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connects to the given address, specified as a sockaddr structure wrapped in a <a class="el" href="class_n_s_data.html">NSData</a> object. For example, a <a class="el" href="class_n_s_data.html">NSData</a> object returned from NSNetservice's addresses method.</p>
<p>If you have an existing struct sockaddr you can convert it to a <a class="el" href="class_n_s_data.html">NSData</a> object like so: struct sockaddr sa -&gt; <a class="el" href="class_n_s_data.html">NSData</a> *dsa = [<a class="el" href="class_n_s_data.html">NSData</a> dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len]; struct sockaddr *sa -&gt; <a class="el" href="class_n_s_data.html">NSData</a> *dsa = [<a class="el" href="class_n_s_data.html">NSData</a> dataWithBytes:remoteAddr length:remoteAddr-&gt;sa_len];</p>
<p>This method invokes connectToAdd </p>

</div>
</div>
<a class="anchor" id="a12de200ef677c49f7b013b1646453dcb"></a><!-- doxytag: member="GCDAsyncSocket::connectToAddress:viaInterface:withTimeout:error:" ref="a12de200ef677c49f7b013b1646453dcb" args="(NSData *remoteAddr,[viaInterface] NSString *interface,[withTimeout] NSTimeInterval timeout,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToAddress: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>remoteAddr</em></td>
        </tr>
        <tr>
          <td class="paramkey">viaInterface:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>interface</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connects to the given address, using the specified interface and timeout.</p>
<p>The address is specified as a sockaddr structure wrapped in a <a class="el" href="class_n_s_data.html">NSData</a> object. For example, a <a class="el" href="class_n_s_data.html">NSData</a> object returned from NSNetservice's addresses method.</p>
<p>If you have an existing struct sockaddr you can convert it to a <a class="el" href="class_n_s_data.html">NSData</a> object like so: struct sockaddr sa -&gt; <a class="el" href="class_n_s_data.html">NSData</a> *dsa = [<a class="el" href="class_n_s_data.html">NSData</a> dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len]; struct sockaddr *sa -&gt; <a class="el" href="class_n_s_data.html">NSData</a> *dsa = [<a class="el" href="class_n_s_data.html">NSData</a> dataWithBytes:remoteAddr length:remoteAddr-&gt;sa_len];</p>
<p>The interface may be a name (e.g. "en1" or "lo0") or the corresponding IP address (e.g. "192.168.4.35"). The interface may also be used to specify the local port (see below).</p>
<p>The timeout is optional. To not time out use a negative time interval.</p>
<p>This method will return NO if an error is detected, and set the error pointer (if one was given). Possible errors would be a nil host, invalid interface, or socket is already connected.</p>
<p>If no errors are detected, this method will start a background connect operation and immediately return YES. The delegate callbacks are used to notify you when the socket connects, or if the host was unreachable.</p>
<p>Since this class supports queued reads and writes, you can immediately start reading and/or writing. All read/write operations will be queued, and upon socket connection, the operations will be dequeued and processed in order.</p>
<p>The interface may optionally contain a port number at the end of the string, separated by a colon. This allows you to specify the local port that should be used for the outgoing connection. (read paragraph to end) To specify both interface and local port: "en1:8082" or "192.168.4.35:2424". To specify only local port: ":8082". Please note this is an advanced feature, and is somewhat hidden on purpose. You should understand that 99.999% of the time you should NOT specify the local port for an outgoing connection. If you think you need to, there is a very good chance you have a fundamental misunderstanding somewhere. Local ports do NOT need to match remote ports. In fact, they almost never do. This feature is here for networking professionals using very advanced techniques.</p>
<p>param <a class="el" href="class_n_s_data.html">NSData</a> param NSString param NSTimeInterval param NSError returns BOOL </p>

</div>
</div>
<a class="anchor" id="ae023e135c607e4ad8a7dd86a1be7efe2"></a><!-- doxytag: member="GCDAsyncSocket::connectToAddress:withTimeout:error:" ref="ae023e135c607e4ad8a7dd86a1be7efe2" args="(NSData *remoteAddr,[withTimeout] NSTimeInterval timeout,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToAddress: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>remoteAddr</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is the same as connectToAddress:error: with an additional timeout option. To not time out use a negative time interval, or simply use the connectToAddress:error: method. param <a class="el" href="class_n_s_data.html">NSData</a> param NSTimeInterval param NSError returns BOOL </p>

</div>
</div>
<a class="anchor" id="a3d9205d70242e9e2547148c6b05b397e"></a><!-- doxytag: member="GCDAsyncSocket::connectToHost:onPort:error:" ref="a3d9205d70242e9e2547148c6b05b397e" args="(NSString *host,[onPort] UInt16 port,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToHost: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>host</em></td>
        </tr>
        <tr>
          <td class="paramkey">onPort:</td>
          <td></td>
          <td class="paramtype">(UInt16)&#160;</td>
          <td class="paramname"><em>port</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connects to the given host and port.</p>
<p>This method invokes connectToHost:onPort:viaInterface:withTimeout:error: and uses the default interface, and no timeout. param NSString param UInt16 returns BOOL</p>
<p>Whether can connect to a host on a particular port host - A DNS name or IP address to which the receiver should connect. Both IPv4 and IPv6 addresses are supported. port - A port number to which the receiver should connect. errPtr - The address of an NSError object pointer. In the event of an error, the pointer will be set to the NSError object describing the error.</p>
<p>param NSString param UInt16 param NSError returns BOOL </p>

<p>Definition at line <a class="el" href="#L2963">2963</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                     :(NSString*)host onPort:(UInt16)port error:(NSError **)errPtr
{
    
        <span class="keywordflow">return</span> [<span class="keyword">self</span> connectToHost:host onPort:port withTimeout:-1 error:errPtr];
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac69dc181fa49533b8cc041d59d38d8f4"></a><!-- doxytag: member="GCDAsyncSocket::connectToHost:onPort:viaInterface:withTimeout:error:" ref="ac69dc181fa49533b8cc041d59d38d8f4" args="(NSString *host,[onPort] UInt16 port,[viaInterface] NSString *interface,[withTimeout] NSTimeInterval timeout,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToHost: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>host</em></td>
        </tr>
        <tr>
          <td class="paramkey">onPort:</td>
          <td></td>
          <td class="paramtype">(UInt16)&#160;</td>
          <td class="paramname"><em>port</em></td>
        </tr>
        <tr>
          <td class="paramkey">viaInterface:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>interface</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connects to the given host &amp; port, via the optional interface, with an optional timeout.</p>
<p>The host may be a domain name (e.g. "deusty.com") or an IP address string (e.g. "192.168.0.2"). The interface may be a name (e.g. "en1" or "lo0") or the corresponding IP address (e.g. "192.168.4.35"). The interface may also be used to specify the local port (see below).</p>
<p>To not time out use a negative time interval.</p>
<p>This method will return NO if an error is detected, and set the error pointer (if one was given). Possible errors would be a nil host, invalid interface, or socket is already connected.</p>
<p>If no errors are detected, this method will start a background connect operation and immediately return YES. The delegate callbacks are used to notify you when the socket connects, or if the host was unreachable.</p>
<p>Since this class supports queued reads and writes, you can immediately start reading and/or writing. All read/write operations will be queued, and upon socket connection, the operations will be dequeued and processed in order.</p>
<p>The interface may optionally contain a port number at the end of the string, separated by a colon. This allows you to specify the local port that should be used for the outgoing connection. (read paragraph to end) To specify both interface and local port: "en1:8082" or "192.168.4.35:2424". To specify only local port: ":8082". Please note this is an advanced feature, and is somewhat hidden on purpose. You should understand that 99.999% of the time you should NOT specify the local port for an outgoing connection. If you think you need to, there is a very good chance you have a fundamental misunderstanding somewhere. Local ports do NOT need to match remote ports. In fact, they almost never do. This feature is here for networking professionals using very advanced techniques.</p>
<p>Whether can connect to host on specific port via a specific interface hostname - A DNS name or IP address to which the receiver should connect. Both IPv4 and IPv6 addresses are supported port - A port number to which the receiver should connect. errPtr - The address of an NSError object pointer. In the event of an error, the pointer will be set to the NSError object describing the error</p>
<p>param NSString param UInt16 param NSString param NSTimeInterval param NSError returns BOOL </p>

</div>
</div>
<a class="anchor" id="a72977694b5f8374592b423a66b1e23a3"></a><!-- doxytag: member="GCDAsyncSocket::connectToHost:onPort:withTimeout:error:" ref="a72977694b5f8374592b423a66b1e23a3" args="(NSString *host,[onPort] UInt16 port,[withTimeout] NSTimeInterval timeout,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectToHost: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>host</em></td>
        </tr>
        <tr>
          <td class="paramkey">onPort:</td>
          <td></td>
          <td class="paramtype">(UInt16)&#160;</td>
          <td class="paramname"><em>port</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connects to the given host and port with an optional timeout.</p>
<p>This method invokes connectToHost:onPort:viaInterface:withTimeout:error: and uses the default interface. param NSString param UInt16 param NSTimeInterval param NSError returns BOOL</p>
<p>Whether can connect to host on a specific port via a specific interface with a specific timeout</p>
<p>param NSString param UInt16 param NSTimeInterval param NSError returns BOOL </p>

<p>Definition at line <a class="el" href="#L2980">2980</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                     :(NSString *)host
               onPort:(UInt16)port
          withTimeout:(NSTimeInterval)timeout
                error:(NSError **)errPtr
{
        <span class="keywordflow">return</span> [<span class="keyword">self</span> connectToHost:host onPort:port viaInterface:nil withTimeout:timeout error:errPtr];
}
</pre></div>
</div>
</div>
<a class="anchor" id="a69a249a85f05de648a8c15e02f4bdbac"></a><!-- doxytag: member="GCDAsyncSocket::connectWithAddress4:address6:error:" ref="a69a249a85f05de648a8c15e02f4bdbac" args="(NSData *address4,[address6] NSData *address6,[error] NSError **errPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectWithAddress4: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>address4</em></td>
        </tr>
        <tr>
          <td class="paramkey">address6:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>address6</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>errPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param <a class="el" href="class_n_s_data.html">NSData</a> param <a class="el" href="class_n_s_data.html">NSData</a> param NSError returns BOOL </p>

</div>
</div>
<a class="anchor" id="aacd220af818626d82e1886970428f8b0"></a><!-- doxytag: member="GCDAsyncSocket::continueSSLHandshake" ref="aacd220af818626d82e1886970428f8b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) continueSSLHandshake </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Continue the SSL handshake </p>

</div>
</div>
<a class="anchor" id="adde78bb75988b51f5c403daebcd91f99"></a><!-- doxytag: member="GCDAsyncSocket::CRData" ref="adde78bb75988b51f5c403daebcd91f99" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (<a class="el" href="class_n_s_data.html">NSData</a> *) CRData </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method returns <a class="el" href="class_n_s_data.html">NSData</a> </p>

</div>
</div>
<a class="anchor" id="a6d7dfcd7967c0e16b86ae64e5579b709"></a><!-- doxytag: member="GCDAsyncSocket::CRLFData" ref="a6d7dfcd7967c0e16b86ae64e5579b709" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (<a class="el" href="class_n_s_data.html">NSData</a> *) CRLFData </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A few common line separators, for use with the readDataToData:... methods. Class method returns <a class="el" href="class_n_s_data.html">NSData</a> </p>

</div>
</div>
<a class="anchor" id="a6c98e239b6ba279cfc95c64db9de555c"></a><!-- doxytag: member="GCDAsyncSocket::delegate" ref="a6c98e239b6ba279cfc95c64db9de555c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) <a class="el" href="interface_g_c_d_async_socket.html#a8d9332fcd23523b1e2520b8765577423">delegate</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the delegate returns id </p>

</div>
</div>
<a class="anchor" id="ad8e601f3e3e4ec791f9a7741ff12aec5"></a><!-- doxytag: member="GCDAsyncSocket::delegateQueue" ref="ad8e601f3e3e4ec791f9a7741ff12aec5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (dispatch_queue_t) <a class="el" href="interface_g_c_d_async_socket.html#a97158c52f2a4011454b4eb3ee369a8a1">delegateQueue</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the delegate queue returns dispatch_queue_t </p>

</div>
</div>
<a class="anchor" id="a82eeef89347f1fec7f2281e6f22dd372"></a><!-- doxytag: member="GCDAsyncSocket::didConnect:" ref="a82eeef89347f1fec7f2281e6f22dd372" args="(int aConnectIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) didConnect: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>aConnectIndex</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int </p>

</div>
</div>
<a class="anchor" id="a9915204aa99bbcd91a8c50c2df4f3955"></a><!-- doxytag: member="GCDAsyncSocket::didNotConnect:error:" ref="a9915204aa99bbcd91a8c50c2df4f3955" args="(int aConnectIndex,[error] NSError *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) didNotConnect: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>aConnectIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError *)&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int param NSError </p>

</div>
</div>
<a class="anchor" id="a960705de531a20389fb29928d43258c3"></a><!-- doxytag: member="GCDAsyncSocket::disconnect" ref="a960705de531a20389fb29928d43258c3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disconnect </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disconnects immediately (synchronously). Any pending reads or writes are dropped. If the socket is not already disconnected, the socketDidDisconnect delegate method will be called immediately, before this method returns.</p>
<p>Please note the recommended way of releasing an AsyncSocket instance (e.g. in a dealloc method) [asyncSocket setDelegate:nil]; [asyncSocket disconnect]; [asyncSocket release]; </p>

</div>
</div>
<a class="anchor" id="a9c49760a3286a595f3cdc0702733baed"></a><!-- doxytag: member="GCDAsyncSocket::disconnectAfterReading" ref="a9c49760a3286a595f3cdc0702733baed" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disconnectAfterReading </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disconnects after all pending reads have completed. After calling this, the read and write methods will do nothing. The socket will disconnect even if there are still pending writes. </p>

</div>
</div>
<a class="anchor" id="a31e39568995cdc85c4feb5a76c645d5f"></a><!-- doxytag: member="GCDAsyncSocket::disconnectAfterReadingAndWriting" ref="a31e39568995cdc85c4feb5a76c645d5f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disconnectAfterReadingAndWriting </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disconnects after all pending reads and writes have completed. After calling this, the read and write methods will do nothing. </p>

</div>
</div>
<a class="anchor" id="a40c9570c2e696d6c48347024fa1f8b5c"></a><!-- doxytag: member="GCDAsyncSocket::disconnectAfterWriting" ref="a40c9570c2e696d6c48347024fa1f8b5c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disconnectAfterWriting </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disconnects after all pending writes have completed. After calling this, the read and write methods will do nothing. The socket will disconnect even if there are still pending reads. </p>

</div>
</div>
<a class="anchor" id="adf2b811edc6945d075c61bfdc82370ac"></a><!-- doxytag: member="GCDAsyncSocket::doAccept:" ref="adf2b811edc6945d075c61bfdc82370ac" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) doAccept: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns boolean </p>

</div>
</div>
<a class="anchor" id="a87f777ed73194b8aa4698bb117b2ddf6"></a><!-- doxytag: member="GCDAsyncSocket::doConnectTimeout" ref="a87f777ed73194b8aa4698bb117b2ddf6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doConnectTimeout </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac699644e023a07acac06ec297f436bef"></a><!-- doxytag: member="GCDAsyncSocket::doReadData" ref="ac699644e023a07acac06ec297f436bef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doReadData </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads data </p>

</div>
</div>
<a class="anchor" id="a6ce5da2611c33dd622ee93777ddcbe84"></a><!-- doxytag: member="GCDAsyncSocket::doReadEOF" ref="a6ce5da2611c33dd622ee93777ddcbe84" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doReadEOF </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read until the end of file terminator </p>

</div>
</div>
<a class="anchor" id="a758d098ce32744465e14d24e35763f73"></a><!-- doxytag: member="GCDAsyncSocket::doReadTimeout" ref="a758d098ce32744465e14d24e35763f73" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doReadTimeout </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5c9a838de41540f52252b4822f2ec49a"></a><!-- doxytag: member="GCDAsyncSocket::doReadTimeoutWithExtension:" ref="a5c9a838de41540f52252b4822f2ec49a" args="(NSTimeInterval timeoutExtension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doReadTimeoutWithExtension: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeoutExtension</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provides for an extension of time param NSTimeInterval </p>

</div>
</div>
<a class="anchor" id="abd9a68b37d6d84c80a138213d54f15e1"></a><!-- doxytag: member="GCDAsyncSocket::doWriteData" ref="abd9a68b37d6d84c80a138213d54f15e1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doWriteData </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes the data to the socket </p>

</div>
</div>
<a class="anchor" id="a806b0275df7c7bb03bf599f711e1429a"></a><!-- doxytag: member="GCDAsyncSocket::doWriteTimeout" ref="a806b0275df7c7bb03bf599f711e1429a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doWriteTimeout </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af01b86e26b678e1f9cf8ad8330a407fe"></a><!-- doxytag: member="GCDAsyncSocket::doWriteTimeoutWithExtension:" ref="af01b86e26b678e1f9cf8ad8330a407fe" args="(NSTimeInterval timeoutExtension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doWriteTimeoutWithExtension: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeoutExtension</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param NSTimeInterval </p>

</div>
</div>
<a class="anchor" id="a26caa9d94af387148d3a2ddf0612d9d7"></a><!-- doxytag: member="GCDAsyncSocket::endConnectTimeout" ref="a26caa9d94af387148d3a2ddf0612d9d7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) endConnectTimeout </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7ddda9613a043ee3044c154ed877e750"></a><!-- doxytag: member="GCDAsyncSocket::endCurrentRead" ref="a7ddda9613a043ee3044c154ed877e750" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) endCurrentRead </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop the current read Cancel the timer and release the current writer </p>

</div>
</div>
<a class="anchor" id="a468b9f90a54b420746956c45daa48d52"></a><!-- doxytag: member="GCDAsyncSocket::endCurrentWrite" ref="a468b9f90a54b420746956c45daa48d52" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) endCurrentWrite </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel the timer and release the current writer </p>

</div>
</div>
<a class="anchor" id="a2e46b6e45efdada29eb5b26883dc8e5c"></a><!-- doxytag: member="GCDAsyncSocket::errnoError" ref="a2e46b6e45efdada29eb5b26883dc8e5c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSError *) errnoError </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns NSError </p>

</div>
</div>
<a class="anchor" id="ab64eb8fd614b2f2502d3e5be1b449a76"></a><!-- doxytag: member="GCDAsyncSocket::errnoErrorWithReason:" ref="ab64eb8fd614b2f2502d3e5be1b449a76" args="(NSString *reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSError *) errnoErrorWithReason: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>reason</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param NSString returns NSError </p>

</div>
</div>
<a class="anchor" id="a25576f025696077083ffab579188d000"></a><!-- doxytag: member="GCDAsyncSocket::gaiError:" ref="a25576f025696077083ffab579188d000" args="(int gai_error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSError *) gaiError: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>gai_error</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns NSError </p>

</div>
</div>
<a class="anchor" id="ac861d6b5813a114fba01d00fecbeb36f"></a><!-- doxytag: member="GCDAsyncSocket::getDelegate:delegateQueue:" ref="ac861d6b5813a114fba01d00fecbeb36f" args="(id *delegatePtr,[delegateQueue] dispatch_queue_t *delegateQueuePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) getDelegate: </td>
          <td></td>
          <td class="paramtype">(id *)&#160;</td>
          <td class="paramname"><em>delegatePtr</em></td>
        </tr>
        <tr>
          <td class="paramkey">delegateQueue:</td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t *)&#160;</td>
          <td class="paramname"><em>delegateQueuePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get delegate and delegate queue param id param dispatch_queue_t</p>
<p>Gets the delegate point and delegate queue pointer param id param dispatch_queue_t </p>

<p>Definition at line <a class="el" href="#L1793">1793</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                   :(<span class="keywordtype">id</span> *)delegatePtr <a class="code" href="interface_g_c_d_async_socket.html#ad8e601f3e3e4ec791f9a7741ff12aec5">delegateQueue</a>:(dispatch_queue_t *)delegateQueuePtr
{
    
    <span class="comment">// Returns the queue on which the currently executing block is running.</span>
    <span class="comment">// In this case, check if the socketQueue is currently running the block</span>
        <span class="keywordflow">if</span> (dispatch_get_current_queue() == <a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>)
        {
        <span class="comment">// If there is a delegate pointer</span>
                <span class="keywordflow">if</span> (delegatePtr)
        {
            *delegatePtr = <a class="code" href="interface_g_c_d_async_socket.html#a6c98e239b6ba279cfc95c64db9de555c">delegate</a>;
        }
        
        <span class="comment">// If there is a delegateQueue pointer</span>
                <span class="keywordflow">if</span> (delegateQueuePtr)
        {
            *delegateQueuePtr = <a class="code" href="interface_g_c_d_async_socket.html#ad8e601f3e3e4ec791f9a7741ff12aec5">delegateQueue</a>;
        }
        
        }
        <span class="keywordflow">else</span>  <span class="comment">// If the current queue is not the socketQueue</span>
        {
        <span class="comment">// Get the delegate pointer and delegate queue from the block</span>
                __block <span class="keywordtype">id</span> dPtr = NULL;
        
        <span class="comment">// Delegate queue pointer</span>
                __block dispatch_queue_t dqPtr = NULL;
                
        
        <span class="comment">//BLOCK</span>
        
        <span class="comment">// Submits a block for synchronous execution on the socketQueue</span>
                dispatch_sync(<a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>, ^{
                        dPtr = <a class="code" href="interface_g_c_d_async_socket.html#a6c98e239b6ba279cfc95c64db9de555c">delegate</a>; <span class="comment">//delegate pointer</span>
                        dqPtr = <a class="code" href="interface_g_c_d_async_socket.html#ad8e601f3e3e4ec791f9a7741ff12aec5">delegateQueue</a>; <span class="comment">// delegate que pointer</span>
                }); <span class="comment">// END OF BLOCK</span>
                
        <span class="comment">// If there is a delegate pointer</span>
                <span class="keywordflow">if</span> (delegatePtr)
        {
            *delegatePtr = dPtr;
        }
        
        <span class="comment">// If there is a delegateQueue pointer</span>
                <span class="keywordflow">if</span> (delegateQueuePtr)
        {
            
            *delegateQueuePtr = dqPtr;
        }
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="adad43bd80dfcbfa004d0732e090544bd"></a><!-- doxytag: member="GCDAsyncSocket::getHost:port:fromAddress:" ref="adad43bd80dfcbfa004d0732e090544bd" args="(NSString **hostPtr,[port] UInt16 *portPtr,[fromAddress] NSData *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (BOOL) getHost: </td>
          <td></td>
          <td class="paramtype">(NSString **)&#160;</td>
          <td class="paramname"><em>hostPtr</em></td>
        </tr>
        <tr>
          <td class="paramkey">port:</td>
          <td></td>
          <td class="paramtype">(UInt16 *)&#160;</td>
          <td class="paramname"><em>portPtr</em></td>
        </tr>
        <tr>
          <td class="paramkey">fromAddress:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method param NSString (pointer to a pointer) param UInt16 param <a class="el" href="class_n_s_data.html">NSData</a> returns BOOL </p>

</div>
</div>
<a class="anchor" id="a872bbd6498010a0c5ce983d91e35fd51"></a><!-- doxytag: member="GCDAsyncSocket::getInterfaceAddress4:address6:fromDescription:port:" ref="a872bbd6498010a0c5ce983d91e35fd51" args="(NSData **addr4Ptr,[address6] NSData **addr6Ptr,[fromDescription] NSString *interfaceDescription,[port] UInt16 port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) getInterfaceAddress4: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> **)&#160;</td>
          <td class="paramname"><em>addr4Ptr</em></td>
        </tr>
        <tr>
          <td class="paramkey">address6:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> **)&#160;</td>
          <td class="paramname"><em>addr6Ptr</em></td>
        </tr>
        <tr>
          <td class="paramkey">fromDescription:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>interfaceDescription</em></td>
        </tr>
        <tr>
          <td class="paramkey">port:</td>
          <td></td>
          <td class="paramtype">(UInt16)&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param <a class="el" href="class_n_s_data.html">NSData</a> param <a class="el" href="class_n_s_data.html">NSData</a> param NSString param unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="a78b15d688675f086c5a84378ee23f79c"></a><!-- doxytag: member="GCDAsyncSocket::hostFromAddress4:" ref="a78b15d688675f086c5a84378ee23f79c" args="(struct sockaddr_in *pSockaddr4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (NSString *) hostFromAddress4: </td>
          <td></td>
          <td class="paramtype">(struct sockaddr_in *)&#160;</td>
          <td class="paramname"><em>pSockaddr4</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method param struct sockaddr_in (IP version 4) returns NSString </p>

</div>
</div>
<a class="anchor" id="aae67418d3932685622e2ff08adbf8f3e"></a><!-- doxytag: member="GCDAsyncSocket::hostFromAddress6:" ref="aae67418d3932685622e2ff08adbf8f3e" args="(struct sockaddr_in6 *pSockaddr6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (NSString *) hostFromAddress6: </td>
          <td></td>
          <td class="paramtype">(struct sockaddr_in6 *)&#160;</td>
          <td class="paramname"><em>pSockaddr6</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method param struct sockaddr_in6 returns NSString </p>

</div>
</div>
<a class="anchor" id="ad25cbed4327e1a30c369f5367af185f0"></a><!-- doxytag: member="GCDAsyncSocket::hostFromAddress:" ref="ad25cbed4327e1a30c369f5367af185f0" args="(NSData *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (NSString *) hostFromAddress: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>address</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method Gets the host from an address param <a class="el" href="class_n_s_data.html">NSData</a> returns NSString </p>

</div>
</div>
<a class="anchor" id="a4213bb26f5207ee3f402fe463badc691"></a><!-- doxytag: member="GCDAsyncSocket::init" ref="a4213bb26f5207ee3f402fe463badc691" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) init </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> uses the standard delegate paradigm, but executes all delegate callbacks on a given delegate dispatch queue. This allows for maximum concurrency, while at the same time providing easy thread safety.</p>
<p>You MUST set a delegate AND delegate dispatch queue before attempting to use the socket, or you will get an error.</p>
<p>The socket queue is optional. If you pass NULL, <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> will automatically create it's own socket queue.</p>
<p>If you choose to provide a socket queue, the socket queue must not be a concurrent queue.</p>
<p>The delegate queue and socket queue can optionally be the same.</p>
<p>Initialize the <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> This message initializes the receiver, setting the delegate at the same time. returns self (instance of <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a>) </p>

<p>Definition at line <a class="el" href="#L1460">1460</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordflow">return</span> [<span class="keyword">self</span> initWithDelegate:nil delegateQueue:NULL socketQueue:NULL];
}
</pre></div>
</div>
</div>
<a class="anchor" id="a504b2a0981de8ea8758effb60245973e"></a><!-- doxytag: member="GCDAsyncSocket::initWithDelegate:delegateQueue:" ref="a504b2a0981de8ea8758effb60245973e" args="(id aDelegate,[delegateQueue] dispatch_queue_t dq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithDelegate: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>aDelegate</em></td>
        </tr>
        <tr>
          <td class="paramkey">delegateQueue:</td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>dq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> with a delegate and delegate queue param dispatch_queue_t returns id (self)</p>
<p>Initialize the <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> with delegate and delegate queue This message initializes the receiver, setting the delegate at the same time.</p>
<p>param id param dispatch_queue_t returns self (instance of <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a>) </p>

<p>Definition at line <a class="el" href="#L1486">1486</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                      :(id)aDelegate <a class="code" href="interface_g_c_d_async_socket.html#ad8e601f3e3e4ec791f9a7741ff12aec5">delegateQueue</a>:(dispatch_queue_t)dq
{
        <span class="keywordflow">return</span> [<span class="keyword">self</span> initWithDelegate:aDelegate delegateQueue:dq socketQueue:NULL];
}
</pre></div>
</div>
</div>
<a class="anchor" id="a75fe279d42a5c8078f8bac4d953c81a8"></a><!-- doxytag: member="GCDAsyncSocket::initWithDelegate:delegateQueue:socketQueue:" ref="a75fe279d42a5c8078f8bac4d953c81a8" args="(id aDelegate,[delegateQueue] dispatch_queue_t dq,[socketQueue] dispatch_queue_t sq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithDelegate: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>aDelegate</em></td>
        </tr>
        <tr>
          <td class="paramkey">delegateQueue:</td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>dq</em></td>
        </tr>
        <tr>
          <td class="paramkey">socketQueue:</td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>sq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> with a delegate, delegate queue, and socket queue param id param dispatch_queue_t param dispatch_queue_t returns id</p>
<p>Initialize the <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> with delegate, delegate queue, and socket queue This message initializes the receiver, setting the delegate at the same time.</p>
<p>param id param dispatch_queue_t param dispatch_queue_t returns self (instance of <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a>) </p>

<p>Definition at line <a class="el" href="#L1500">1500</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                      :(id)aDelegate <a class="code" href="interface_g_c_d_async_socket.html#ad8e601f3e3e4ec791f9a7741ff12aec5">delegateQueue</a>:(dispatch_queue_t)dq <a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>:(dispatch_queue_t)sq
{
        <span class="keywordflow">if</span>((<span class="keyword">self</span> = [super <a class="code" href="interface_g_c_d_async_socket.html#a4213bb26f5207ee3f402fe463badc691">init</a>]))
        {
        <span class="comment">// Sets the socket delegate</span>
                <a class="code" href="interface_g_c_d_async_socket.html#a6c98e239b6ba279cfc95c64db9de555c">delegate</a> = aDelegate;
                
        <span class="comment">// Test if there is a delegat queue</span>
                <span class="keywordflow">if</span> (dq)
                {
            <span class="comment">// Increment the reference count of the delegate queue</span>
                        dispatch_retain(dq);
                        <a class="code" href="interface_g_c_d_async_socket.html#ad8e601f3e3e4ec791f9a7741ff12aec5">delegateQueue</a> = dq;
                }
                
                <a class="code" href="interface_g_c_d_async_socket.html#a2b9c119ffa6ff18321572f26a759b9ed">socket4FD</a> = <a class="code" href="_g_c_d_async_socket_8m.html#aff67b96affb34fbb2dace4386402202c">SOCKET_NULL</a>;
                <a class="code" href="interface_g_c_d_async_socket.html#ad6120d297c599aff1e50bd2ce917e3ad">socket6FD</a> = <a class="code" href="_g_c_d_async_socket_8m.html#aff67b96affb34fbb2dace4386402202c">SOCKET_NULL</a>;
                <a class="code" href="interface_g_c_d_async_socket.html#adead8a55f9eb7ea6b017928b8f07ba88">connectIndex</a> = 0;
                
                <span class="keywordflow">if</span> (sq) <span class="comment">// socket queue</span>
                {
            <span class="comment">// Make sure the socket queue is not a global concurrence queue</span>
                        NSString *assertMsg = <span class="stringliteral">@&quot;The given socketQueue parameter must not be a concurrent queue.&quot;</span>;
                        
            
            <span class="comment">// Test whether the socket queue is not equal to the global queue values</span>
                        NSAssert(sq != dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), assertMsg);
                        NSAssert(sq != dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), assertMsg);
                        NSAssert(sq != dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), assertMsg);
                        
                        dispatch_retain(sq);  <span class="comment">// Increments the reference to socket queue</span>
                        <a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a> = sq;
                }
                <span class="keywordflow">else</span>  <span class="comment">// if there isn&#39;t a socket queue, then create one</span>
                {
            <span class="comment">// Creates the Grand Central Dispatch AsyncSocket queue</span>
                        <a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a> = dispatch_queue_create(<span class="stringliteral">&quot;GCDAsyncSocket&quot;</span>, NULL);
                }
                
        <span class="comment">// Create readqueue mutable array with capacity of 5</span>
                <a class="code" href="interface_g_c_d_async_socket.html#a93d45803a1d4682aaefb278b0a2bd93f">readQueue</a> = [[NSMutableArray alloc] initWithCapacity:5];
                <a class="code" href="interface_g_c_d_async_socket.html#ac6eeee8bb60215eea067cdfcb844f557">currentRead</a> = nil;
                
        <span class="comment">// Create writequeue mutable array with capacity of 5</span>
                <a class="code" href="interface_g_c_d_async_socket.html#a1ad8da0672218827b7a1a4abbdf1f34d">writeQueue</a> = [[NSMutableArray alloc] initWithCapacity:5];
                <a class="code" href="interface_g_c_d_async_socket.html#a4b3234a5bb213a8af4cf4b3e3f2548e5">currentWrite</a> = nil;
                
        <span class="comment">// Create partial read buffer for the host message</span>
                <a class="code" href="interface_g_c_d_async_socket.html#a2c92583ab159460443b3d9b73b2b4156">partialReadBuffer</a> = [[NSMutableData alloc] init];
        }
        <span class="keywordflow">return</span> <span class="keyword">self</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaa7a544e6a86f4df110ff353e4a10597"></a><!-- doxytag: member="GCDAsyncSocket::initWithSocketQueue:" ref="aaa7a544e6a86f4df110ff353e4a10597" args="(dispatch_queue_t sq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithSocketQueue: </td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>sq</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> with a socket queue</p>
<p>param dispatch_queue_t returns id (self)</p>
<p>Initialize the <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> with a socket queue</p>
<p>param dispatch_queue_t returns self (instance of <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a>) </p>

<p>Definition at line <a class="el" href="#L1471">1471</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                         :(dispatch_queue_t)sq
{
    
    <span class="comment">// This message initializes the receiver, setting the delegate at the same time.</span>
        <span class="keywordflow">return</span> [<span class="keyword">self</span> initWithDelegate:nil delegateQueue:NULL socketQueue:sq];
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad3515f7fe2b8ed2b9e14233cf7ede0bc"></a><!-- doxytag: member="GCDAsyncSocket::isConnected" ref="ad3515f7fe2b8ed2b9e14233cf7ede0bc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isConnected </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns BOOL </p>

</div>
</div>
<a class="anchor" id="a72a57ce3f39762161947846bbe03a621"></a><!-- doxytag: member="GCDAsyncSocket::isDisconnected" ref="a72a57ce3f39762161947846bbe03a621" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isDisconnected </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether the socket is disconnected or connected.</p>
<p>A disconnected socket may be recycled. That is, it can used again for connecting or listening.</p>
<p>If a socket is in the process of connecting, it may be neither disconnected nor connected. </p>

</div>
</div>
<a class="anchor" id="a7f1734034c9aa5b62cfeb69f203729e3"></a><!-- doxytag: member="GCDAsyncSocket::isIPv4" ref="a7f1734034c9aa5b62cfeb69f203729e3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isIPv4 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether the socket is IPv4 or IPv6. An accepting socket may be both. returns BOOL </p>

</div>
</div>
<a class="anchor" id="a9fd367a3576e58665df01f6a376621eb"></a><!-- doxytag: member="GCDAsyncSocket::isIPv4Enabled" ref="a9fd367a3576e58665df01f6a376621eb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isIPv4Enabled </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>By default, both IPv4 and IPv6 are enabled.</p>
<p>For accepting incoming connections, this means <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> automatically supports both protocols, and can simulataneously accept incoming connections on either protocol.</p>
<p>For outgoing connections, this means <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> can connect to remote hosts running either protocol. If a DNS lookup returns only IPv4 results, <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> will automatically use IPv4. If a DNS lookup returns only IPv6 results, <a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a> will automatically use IPv6. If a DNS lookup returns both IPv4 and IPv6 results, the preferred protocol will be chosen. By default, the preferred protocol is IPv4, but may be configured as desired. Whether IP version 4 is enabled returns BOOL</p>
<p>Returns whether IP version 4 is enabled returns BOOL </p>

<p>Definition at line <a class="el" href="#L1981">1981</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="comment">// Note: YES means kIPv4Disabled is OFF</span>
        
    <span class="comment">// Returns the queue on which the currently executing block is running.</span>
    <span class="comment">// In this case, check if the socketQueue is currently running the block</span>
        <span class="keywordflow">if</span> (dispatch_get_current_queue() == <a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>)
        {
                <span class="keywordflow">return</span> ((<a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> &amp; <a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059a5e1715b3fa60f2fe05eaf896dfee0cf8" title="If set, IPv4 is disabled.">kIPv4Disabled</a>) == 0);
        }
        <span class="keywordflow">else</span>
        {
        <span class="comment">// Gets the result from the block</span>
                __block BOOL result;
                
        <span class="comment">// Submits a block for synchronous execution on a dispatch queue.</span>
                dispatch_sync(<a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>, ^{
            
            <span class="comment">// If set, IPv4 is disabled</span>
                        result = ((<a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> &amp; <a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059a5e1715b3fa60f2fe05eaf896dfee0cf8" title="If set, IPv4 is disabled.">kIPv4Disabled</a>) == 0);
            
                }); <span class="comment">// END OF BLOCK</span>
                
                <span class="keywordflow">return</span> result;
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac8a98d880cd216a59a118b9243f9896d"></a><!-- doxytag: member="GCDAsyncSocket::isIPv4PreferredOverIPv6" ref="ac8a98d880cd216a59a118b9243f9896d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isIPv4PreferredOverIPv6 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Whether IP version 4 protocol is preferred over IP version 6 protocol returns BOOL</p>
<p>Whether IP version 4 is preferred over IP version 6 returns BOOL </p>

<p>Definition at line <a class="el" href="#L2105">2105</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="comment">// Note: YES means kPreferIPv6 is OFF</span>
        
    <span class="comment">// Returns the queue on which the currently executing block is running.</span>
    <span class="comment">// In this case, check if the socketQueue is currently running the block</span>
        <span class="keywordflow">if</span> (dispatch_get_current_queue() == <a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>)
        {
                <span class="keywordflow">return</span> ((<a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> &amp; <a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059ad5d90a1865a0b0c1de05cf862ec91d61" title="If set, IPv6 is preferred over IPv4.">kPreferIPv6</a>) == 0);
        }
        <span class="keywordflow">else</span>
        {
        <span class="comment">// Gets the result from the block</span>
                __block BOOL result;
                
        <span class="comment">// Submits a block for synchronous execution on a dispatch queue.</span>
                dispatch_sync(<a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>, ^{
                        result = ((<a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> &amp; <a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059ad5d90a1865a0b0c1de05cf862ec91d61" title="If set, IPv6 is preferred over IPv4.">kPreferIPv6</a>) == 0);
                }); <span class="comment">// END OF BLOCK</span>
                
                <span class="keywordflow">return</span> result;
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa009ac699bce64f1d087a0eafeb2a371"></a><!-- doxytag: member="GCDAsyncSocket::isIPv6" ref="aa009ac699bce64f1d087a0eafeb2a371" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isIPv6 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns BOOL </p>

</div>
</div>
<a class="anchor" id="a86e92e8be0617f9ec2ae403d5ff3a04e"></a><!-- doxytag: member="GCDAsyncSocket::isIPv6Enabled" ref="a86e92e8be0617f9ec2ae403d5ff3a04e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isIPv6Enabled </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Whether IP version 6 protocol is enabled returns BOOL</p>
<p>Returns whether IP version 6 is enabled returns BOOL </p>

<p>Definition at line <a class="el" href="#L2044">2044</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="comment">// Note: YES means kIPv6Disabled is OFF</span>
        
    
    <span class="comment">// Returns the queue on which the currently executing block is running.</span>
    <span class="comment">// In this case, check if the socketQueue is currently running the block</span>
        <span class="keywordflow">if</span> (dispatch_get_current_queue() == <a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>)
        {
                <span class="keywordflow">return</span> ((<a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> &amp; <a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059a94e72322e8d8380318632317bc451eee" title="If set, IPv6 is disabled.">kIPv6Disabled</a>) == 0);
        }
        <span class="keywordflow">else</span>
        {
        <span class="comment">// Gets the result from the block</span>
                __block BOOL result;
                
        <span class="comment">// Submits a block for synchronous execution on a dispatch queue.</span>
                dispatch_sync(<a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>, ^{
                        result = ((<a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> &amp; <a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059a94e72322e8d8380318632317bc451eee" title="If set, IPv6 is disabled.">kIPv6Disabled</a>) == 0);
                }); <span class="comment">// END OF BLOCK</span>
                
                <span class="keywordflow">return</span> result;
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9f80c130183f3fa0f324c7505127ab77"></a><!-- doxytag: member="GCDAsyncSocket::LFData" ref="a9f80c130183f3fa0f324c7505127ab77" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (<a class="el" href="class_n_s_data.html">NSData</a> *) LFData </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method returns <a class="el" href="class_n_s_data.html">NSData</a> </p>

</div>
</div>
<a class="anchor" id="a279be33392f836041828ae18ed4678a3"></a><!-- doxytag: member="GCDAsyncSocket::localAddress" ref="a279be33392f836041828ae18ed4678a3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="class_n_s_data.html">NSData</a> *) localAddress </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns <a class="el" href="class_n_s_data.html">NSData</a> </p>

</div>
</div>
<a class="anchor" id="a544fa124053aea063a8be148cf24d491"></a><!-- doxytag: member="GCDAsyncSocket::localHost" ref="a544fa124053aea063a8be148cf24d491" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) localHost </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns NSString </p>

</div>
</div>
<a class="anchor" id="a4702ea42737d8732eff7d37bb661d1fb"></a><!-- doxytag: member="GCDAsyncSocket::localHost4" ref="a4702ea42737d8732eff7d37bb661d1fb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) localHost4 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns NSString </p>

</div>
</div>
<a class="anchor" id="ac5a80b83d64f10ebc037ecbe91002347"></a><!-- doxytag: member="GCDAsyncSocket::localHost6" ref="ac5a80b83d64f10ebc037ecbe91002347" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) localHost6 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns NSString </p>

</div>
</div>
<a class="anchor" id="a1c7469573dd259dd7758c752638bb6b0"></a><!-- doxytag: member="GCDAsyncSocket::localHostFromSocket4:" ref="a1c7469573dd259dd7758c752638bb6b0" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) localHostFromSocket4: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns NSString </p>

</div>
</div>
<a class="anchor" id="ac37c12af87e892233a18bddf93b317e7"></a><!-- doxytag: member="GCDAsyncSocket::localHostFromSocket6:" ref="ac37c12af87e892233a18bddf93b317e7" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) localHostFromSocket6: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns NSString </p>

</div>
</div>
<a class="anchor" id="a1b6cdcf368d68e9ffb28e359e5c23ce8"></a><!-- doxytag: member="GCDAsyncSocket::localPort" ref="a1b6cdcf368d68e9ffb28e359e5c23ce8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) localPort </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns UInt16 </p>

</div>
</div>
<a class="anchor" id="a11c3a22df8764878ede33514c4e6e81e"></a><!-- doxytag: member="GCDAsyncSocket::localPort4" ref="a11c3a22df8764878ede33514c4e6e81e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) localPort4 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="a21bd5ee77206fb4d740cfe6e2e546d57"></a><!-- doxytag: member="GCDAsyncSocket::localPort6" ref="a21bd5ee77206fb4d740cfe6e2e546d57" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) localPort6 </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="a30b4b1539bf92f40c06b773216450c46"></a><!-- doxytag: member="GCDAsyncSocket::localPortFromSocket4:" ref="a30b4b1539bf92f40c06b773216450c46" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) localPortFromSocket4: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="ad5635ba68ed384dcfd5728fb456ee37d"></a><!-- doxytag: member="GCDAsyncSocket::localPortFromSocket6:" ref="ad5635ba68ed384dcfd5728fb456ee37d" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) localPortFromSocket6: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="a2b0440d4004fff8ccc8cecd08b499b67"></a><!-- doxytag: member="GCDAsyncSocket::lookup:didFail:" ref="a2b0440d4004fff8ccc8cecd08b499b67" args="(int aConnectIndex,[didFail] NSError *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) lookup: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>aConnectIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">didFail:</td>
          <td></td>
          <td class="paramtype">(NSError *)&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int param NSError </p>

</div>
</div>
<a class="anchor" id="a324f120c3c25c99a68d462e398e310ee"></a><!-- doxytag: member="GCDAsyncSocket::lookup:didSucceedWithAddress4:address6:" ref="a324f120c3c25c99a68d462e398e310ee" args="(int aConnectIndex,[didSucceedWithAddress4] NSData *address4,[address6] NSData *address6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) lookup: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>aConnectIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">didSucceedWithAddress4:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>address4</em></td>
        </tr>
        <tr>
          <td class="paramkey">address6:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>address6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int param <a class="el" href="class_n_s_data.html">NSData</a> param <a class="el" href="class_n_s_data.html">NSData</a> </p>

</div>
</div>
<a class="anchor" id="ada876adf7aa6dd0e85eac5dd88d0487a"></a><!-- doxytag: member="GCDAsyncSocket::lookup:host:port:" ref="ada876adf7aa6dd0e85eac5dd88d0487a" args="(int aConnectIndex,[host] NSString *host,[port] UInt16 port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) lookup: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>aConnectIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">host:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>host</em></td>
        </tr>
        <tr>
          <td class="paramkey">port:</td>
          <td></td>
          <td class="paramtype">(UInt16)&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param int param NSString param UInt16 </p>

</div>
</div>
<a class="anchor" id="a9d104e16cf86945653536862fbb11b20"></a><!-- doxytag: member="GCDAsyncSocket::maybeClose" ref="a9d104e16cf86945653536862fbb11b20" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) maybeClose </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if can close the connection </p>

</div>
</div>
<a class="anchor" id="a71ded98e88b1001fd651951a35654734"></a><!-- doxytag: member="GCDAsyncSocket::maybeDequeueRead" ref="a71ded98e88b1001fd651951a35654734" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) maybeDequeueRead </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Conditionally starts a new read.</p>
<p>It is called when:</p>
<ul>
<li>a user requests a read</li>
<li>after a read request has finished (to handle the next request)</li>
<li>immediately after the socket opens to handle any pending requests</li>
</ul>
<p>This method also handles auto-disconnect post read completion. </p>

</div>
</div>
<a class="anchor" id="a185ab7cd6a129e604a01195589db6ea7"></a><!-- doxytag: member="GCDAsyncSocket::maybeDequeueWrite" ref="a185ab7cd6a129e604a01195589db6ea7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) maybeDequeueWrite </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Conditionally starts a new write.</p>
<p>It is called when:</p>
<ul>
<li>a user requests a write</li>
<li>after a write request has finished (to handle the next request)</li>
<li>immediately after the socket opens to handle any pending requests</li>
</ul>
<p>This method also handles auto-disconnect post read/write completion. </p>

</div>
</div>
<a class="anchor" id="a1bc43cb9e0ad8f6e03562838e3a61c9e"></a><!-- doxytag: member="GCDAsyncSocket::maybeStartTLS" ref="a1bc43cb9e0ad8f6e03562838e3a61c9e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) maybeStartTLS </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Conditionally start trasport layer security </p>

</div>
</div>
<a class="anchor" id="a5d930a6904127fd8b0c5cc85dfc5bb87"></a><!-- doxytag: member="GCDAsyncSocket::otherError:" ref="a5d930a6904127fd8b0c5cc85dfc5bb87" args="(NSString *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSError *) otherError: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>msg</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param msg returns NSError </p>

</div>
</div>
<a class="anchor" id="a0f9e5a401b98234ed1522174f1ef5d33"></a><!-- doxytag: member="GCDAsyncSocket::performBlock:" ref="a0f9e5a401b98234ed1522174f1ef5d33" args="(dispatch_block_t block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) performBlock: </td>
          <td></td>
          <td class="paramtype">(dispatch_block_t)&#160;</td>
          <td class="paramname"><em>block</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>It's not thread-safe to access certain variables from outside the socket's internal queue.</p>
<p>For example, the socket file descriptor. File descriptors are simply integers which reference an index in the per-process file table. However, when one requests a new file descriptor (by opening a file or socket), the file descriptor returned is guaranteed to be the lowest numbered unused descriptor. So if we're not careful, the following could be possible:</p>
<ul>
<li>Thread A invokes a method which returns the socket's file descriptor.</li>
<li>The socket is closed via the socket's internal queue on thread B.</li>
<li>Thread C opens a file, and subsequently receives the file descriptor that was previously the socket's FD.</li>
<li>Thread A is now accessing/altering the file instead of the socket.</li>
</ul>
<p>In addition to this, other variables are not actually objects, and thus cannot be retained/released or even autoreleased. An example is the sslContext, of type SSLContextRef, which is actually a malloc'd struct.</p>
<p>Although there are internal variables that make it difficult to maintain thread-safety, it is important to provide access to these variables to ensure this class can be used in a wide array of environments. This method helps to accomplish this by invoking the current block on the socket's internal queue. The methods below can be invoked from within the block to access those generally thread-unsafe internal variables in a thread-safe manner. The given block will be invoked synchronously on the socket's internal queue.</p>
<p>If you save references to any protected variables and use them outside the block, you do so at your own peril. </p>

</div>
</div>
<a class="anchor" id="abb46f6848a640f3546c885001065184b"></a><!-- doxytag: member="GCDAsyncSocket::portFromAddress4:" ref="abb46f6848a640f3546c885001065184b" args="(struct sockaddr_in *pSockaddr4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (UInt16) portFromAddress4: </td>
          <td></td>
          <td class="paramtype">(struct sockaddr_in *)&#160;</td>
          <td class="paramname"><em>pSockaddr4</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method param struck sockaddr_in (IP version 4) returns unsigned 16-bit integer </p>

</div>
</div>
<a class="anchor" id="ac731b6646d8ac41864b5e9add9440fcc"></a><!-- doxytag: member="GCDAsyncSocket::portFromAddress6:" ref="ac731b6646d8ac41864b5e9add9440fcc" args="(struct sockaddr_in6 *pSockaddr6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (UInt16) portFromAddress6: </td>
          <td></td>
          <td class="paramtype">(struct sockaddr_in6 *)&#160;</td>
          <td class="paramname"><em>pSockaddr6</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method param struct sockaddr_in6 (IP version 6) returns UInt16 </p>

</div>
</div>
<a class="anchor" id="a3a18b9c4019805df06935f1b2c0ba0e4"></a><!-- doxytag: member="GCDAsyncSocket::portFromAddress:" ref="a3a18b9c4019805df06935f1b2c0ba0e4" args="(NSData *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (UInt16) portFromAddress: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>address</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method Get the port from an address param <a class="el" href="class_n_s_data.html">NSData</a> returns UInt16 </p>

</div>
</div>
<a class="anchor" id="a2a8c215b2b1baee60b831081a5e302ac"></a><!-- doxytag: member="GCDAsyncSocket::readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:" ref="a2a8c215b2b1baee60b831081a5e302ac" args="(NSData *data,[withTimeout] NSTimeInterval timeout,[buffer] NSMutableData *buffer,[bufferOffset] NSUInteger offset,[maxLength] NSUInteger length,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToData: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>data</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">buffer:</td>
          <td></td>
          <td class="paramtype">(NSMutableData *)&#160;</td>
          <td class="paramname"><em>buffer</em></td>
        </tr>
        <tr>
          <td class="paramkey">bufferOffset:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">maxLength:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>length</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads bytes until (and including) the passed "data" parameter, which acts as a separator. The bytes will be appended to the given byte buffer starting at the given offset. The given buffer will automatically be increased in size if needed.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. If the buffer if nil, a buffer will automatically be created for you.</p>
<p>If maxLength is zero, no length restriction is enforced. Otherwise if maxLength bytes are read without completing the read, it is treated similarly to a timeout - the socket is closed with a GCDAsyncSocketReadMaxedOutError. The read will complete successfully if exactly maxLength bytes are read and the given data is found at the end.</p>
<p>If you pass a maxLength parameter that is less than the length of the data parameter, the method will do nothing, and the delegate will not be called. If the bufferOffset is greater than the length of the given buffer, the method will do nothing, and the delegate will not be called.</p>
<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it. After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer. That is, it will reference the bytes that were appended to the given buffer.</p>
<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the "data" parameter. Note that this method is not character-set aware, so if a separator can occur naturally as part of the encoding for a character, the read will prematurely end. </p>

</div>
</div>
<a class="anchor" id="a8782b6bf0862529a8efad865b20eb55f"></a><!-- doxytag: member="GCDAsyncSocket::readDataToData:withTimeout:buffer:bufferOffset:tag:" ref="a8782b6bf0862529a8efad865b20eb55f" args="(NSData *data,[withTimeout] NSTimeInterval timeout,[buffer] NSMutableData *buffer,[bufferOffset] NSUInteger offset,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToData: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>data</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">buffer:</td>
          <td></td>
          <td class="paramtype">(NSMutableData *)&#160;</td>
          <td class="paramname"><em>buffer</em></td>
        </tr>
        <tr>
          <td class="paramkey">bufferOffset:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads bytes until (and including) the passed "data" parameter, which acts as a separator. The bytes will be appended to the given byte buffer starting at the given offset. The given buffer will automatically be increased in size if needed.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. If the buffer if nil, a buffer will automatically be created for you.</p>
<p>If the bufferOffset is greater than the length of the given buffer, the method will do nothing, and the delegate will not be called.</p>
<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it. After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer. That is, it will reference the bytes that were appended to the given buffer.</p>
<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the "data" parameter. Note that this method is not character-set aware, so if a separator can occur naturally as part of the encoding for a character, the read will prematurely end. </p>

</div>
</div>
<a class="anchor" id="abfb0d880d5853402309d80151c19ef85"></a><!-- doxytag: member="GCDAsyncSocket::readDataToData:withTimeout:maxLength:tag:" ref="abfb0d880d5853402309d80151c19ef85" args="(NSData *data,[withTimeout] NSTimeInterval timeout,[maxLength] NSUInteger length,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToData: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>data</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">maxLength:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>length</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads bytes until (and including) the passed "data" parameter, which acts as a separator.</p>
<p>If the timeout value is negative, the read operation will not use a timeout.</p>
<p>If maxLength is zero, no length restriction is enforced. Otherwise if maxLength bytes are read without completing the read, it is treated similarly to a timeout - the socket is closed with a GCDAsyncSocketReadMaxedOutError. The read will complete successfully if exactly maxLength bytes are read and the given data is found at the end.</p>
<p>If you pass nil or zero-length data as the "data" parameter, the method will do nothing, and the delegate will not be called. If you pass a maxLength parameter that is less than the length of the data parameter, the method will do nothing, and the delegate will not be called.</p>
<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the "data" parameter. Note that this method is not character-set aware, so if a separator can occur naturally as part of the encoding for a character, the read will prematurely end. </p>

</div>
</div>
<a class="anchor" id="a3a92e46de7766b3ac649f3d68d370599"></a><!-- doxytag: member="GCDAsyncSocket::readDataToData:withTimeout:tag:" ref="a3a92e46de7766b3ac649f3d68d370599" args="(NSData *data,[withTimeout] NSTimeInterval timeout,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToData: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>data</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads bytes until (and including) the passed "data" parameter, which acts as a separator.</p>
<p>If the timeout value is negative, the read operation will not use a timeout.</p>
<p>If you pass nil or zero-length data as the "data" parameter, the method will do nothing, and the delegate will not be called.</p>
<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the "data" parameter. Note that this method is not character-set aware, so if a separator can occur naturally as part of the encoding for a character, the read will prematurely end. </p>

</div>
</div>
<a class="anchor" id="a7f742375bde66d11c43a478835c04805"></a><!-- doxytag: member="GCDAsyncSocket::readDataToLength:withTimeout:buffer:bufferOffset:tag:" ref="a7f742375bde66d11c43a478835c04805" args="(NSUInteger length,[withTimeout] NSTimeInterval timeout,[buffer] NSMutableData *buffer,[bufferOffset] NSUInteger offset,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToLength: </td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>length</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">buffer:</td>
          <td></td>
          <td class="paramtype">(NSMutableData *)&#160;</td>
          <td class="paramname"><em>buffer</em></td>
        </tr>
        <tr>
          <td class="paramkey">bufferOffset:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the given number of bytes. The bytes will be appended to the given byte buffer starting at the given offset. The given buffer will automatically be increased in size if needed.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. If the buffer if nil, a buffer will automatically be created for you.</p>
<p>If the length is 0, this method does nothing and the delegate is not called. If the bufferOffset is greater than the length of the given buffer, the method will do nothing, and the delegate will not be called.</p>
<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it. After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer. That is, it will reference the bytes that were appended to the given buffer. </p>

</div>
</div>
<a class="anchor" id="a2acf5d5f2c006ea0e14a97b8802bdf7d"></a><!-- doxytag: member="GCDAsyncSocket::readDataToLength:withTimeout:tag:" ref="a2acf5d5f2c006ea0e14a97b8802bdf7d" args="(NSUInteger length,[withTimeout] NSTimeInterval timeout,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataToLength: </td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>length</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the given number of bytes.</p>
<p>If the timeout value is negative, the read operation will not use a timeout.</p>
<p>If the length is 0, this method does nothing and the delegate is not called. </p>

</div>
</div>
<a class="anchor" id="a9ec74c83f6f87dfd8980c98deae38640"></a><!-- doxytag: member="GCDAsyncSocket::readDataWithTimeout:buffer:bufferOffset:maxLength:tag:" ref="a9ec74c83f6f87dfd8980c98deae38640" args="(NSTimeInterval timeout,[buffer] NSMutableData *buffer,[bufferOffset] NSUInteger offset,[maxLength] NSUInteger length,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataWithTimeout: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">buffer:</td>
          <td></td>
          <td class="paramtype">(NSMutableData *)&#160;</td>
          <td class="paramname"><em>buffer</em></td>
        </tr>
        <tr>
          <td class="paramkey">bufferOffset:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">maxLength:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>length</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the first available bytes that become available on the socket. The bytes will be appended to the given byte buffer starting at the given offset. The given buffer will automatically be increased in size if needed. A maximum of length bytes will be read.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. If the buffer if nil, a buffer will automatically be created for you. If maxLength is zero, no length restriction is enforced.</p>
<p>If the bufferOffset is greater than the length of the given buffer, the method will do nothing, and the delegate will not be called.</p>
<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it. After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer. That is, it will reference the bytes that were appended to the given buffer. </p>

</div>
</div>
<a class="anchor" id="a289b8c694675c219c9726385c90e8068"></a><!-- doxytag: member="GCDAsyncSocket::readDataWithTimeout:buffer:bufferOffset:tag:" ref="a289b8c694675c219c9726385c90e8068" args="(NSTimeInterval timeout,[buffer] NSMutableData *buffer,[bufferOffset] NSUInteger offset,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataWithTimeout: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">buffer:</td>
          <td></td>
          <td class="paramtype">(NSMutableData *)&#160;</td>
          <td class="paramname"><em>buffer</em></td>
        </tr>
        <tr>
          <td class="paramkey">bufferOffset:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the first available bytes that become available on the socket. The bytes will be appended to the given byte buffer starting at the given offset. The given buffer will automatically be increased in size if needed.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. If the buffer if nil, the socket will create a buffer for you.</p>
<p>If the bufferOffset is greater than the length of the given buffer, the method will do nothing, and the delegate will not be called.</p>
<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it. After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer. That is, it will reference the bytes that were appended to the given buffer. </p>

</div>
</div>
<a class="anchor" id="a58e63ca19338d5e052ad36e2e64ec585"></a><!-- doxytag: member="GCDAsyncSocket::readDataWithTimeout:tag:" ref="a58e63ca19338d5e052ad36e2e64ec585" args="(NSTimeInterval timeout,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) readDataWithTimeout: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the first available bytes that become available on the socket.</p>
<p>If the timeout value is negative, the read operation will not use a timeout. </p>

</div>
</div>
<a class="anchor" id="a31e716bfc42afec3ea1588b2d875dc93"></a><!-- doxytag: member="GCDAsyncSocket::resumeReadSource" ref="a31e716bfc42afec3ea1588b2d875dc93" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) resumeReadSource </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resumes the read source </p>

</div>
</div>
<a class="anchor" id="a6f47f83f8897b1d29eee31935e659641"></a><!-- doxytag: member="GCDAsyncSocket::resumeWriteSource" ref="a6f47f83f8897b1d29eee31935e659641" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) resumeWriteSource </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resumes the write source </p>

</div>
</div>
<a class="anchor" id="adc2fecde2f4d460a7e8d010d9cf01300"></a><!-- doxytag: member="GCDAsyncSocket::setAutoDisconnectOnClosedReadStream:" ref="adc2fecde2f4d460a7e8d010d9cf01300" args="(BOOL flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setAutoDisconnectOnClosedReadStream: </td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>flag</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the flag for whether automatically disconnecting upon the closing of a read stream param BOOL</p>
<p>Sets the flag for whether to automatically disconnect upon closing the read stream param BOOL </p>

<p>Definition at line <a class="el" href="#L1951">1951</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                                           :(BOOL)flag
{
        <span class="comment">// Note: YES means kAllowHalfDuplexConnection is OFF</span>
        
    <span class="comment">// The prototype of blocks submitted to dispatch queues, which take no arguments and have no return value.</span>
        dispatch_block_t block = ^{
                
                <span class="keywordflow">if</span> (flag)
        {
                        <a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> &amp;= ~<a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059ab4ef22464cc0e8c0c575e94595dcb5bc" title="If set, the socket will stay open even if the read stream closes.">kAllowHalfDuplexConnection</a>;
                }<span class="keywordflow">else</span>{
                        <a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> |= <a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059ab4ef22464cc0e8c0c575e94595dcb5bc" title="If set, the socket will stay open even if the read stream closes.">kAllowHalfDuplexConnection</a>;
        }
        }; <span class="comment">// END OF BLOCK</span>
        
    <span class="comment">// Returns the queue on which the currently executing block is running.</span>
    <span class="comment">// In this case, check if the socketQueue is currently running the block</span>
        <span class="keywordflow">if</span> (dispatch_get_current_queue() == <a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>)
    {
                block(); <span class="comment">// submits the block to the socketQueue</span>
        }<span class="keywordflow">else</span>{
        <span class="comment">// Submits block to the socketQueue asynchronously because it is not the current queue.</span>
                dispatch_async(<a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>, block);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5147f10c2f5e0df2682c4ce073138ac8"></a><!-- doxytag: member="GCDAsyncSocket::setDelegate:" ref="a5147f10c2f5e0df2682c4ce073138ac8" args="(id delegate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setDelegate: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>newDelegate</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the delegate param id </p>

<p>Definition at line <a class="el" href="#L1677">1677</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                   :(id)newDelegate
{
    <span class="comment">// Sets the delegate as the newDelegate for asynchronous execution of blocks</span>
        [<span class="keyword">self</span> setDelegate:newDelegate synchronously:NO];
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7e25f164690499ebb02ad52944ebd4f5"></a><!-- doxytag: member="GCDAsyncSocket::setDelegate:delegateQueue:" ref="a7e25f164690499ebb02ad52944ebd4f5" args="(id delegate,[delegateQueue] dispatch_queue_t delegateQueue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setDelegate: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>newDelegate</em></td>
        </tr>
        <tr>
          <td class="paramkey">delegateQueue:</td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>newDelegateQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the delegate and delegate queue param id param dispatch_queue_t</p>
<p>Sets the delegate and delegate queue param id param dispatch_queue_t </p>

<p>Definition at line <a class="el" href="#L1902">1902</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                   :(id)newDelegate <a class="code" href="interface_g_c_d_async_socket.html#ad8e601f3e3e4ec791f9a7741ff12aec5">delegateQueue</a>:(dispatch_queue_t)newDelegateQueue
{
    
        [<span class="keyword">self</span> setDelegate:newDelegate delegateQueue:newDelegateQueue synchronously:NO];
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad2a40c88499dd4d26e1ee23e51619dd2"></a><!-- doxytag: member="GCDAsyncSocket::setDelegateQueue:" ref="ad2a40c88499dd4d26e1ee23e51619dd2" args="(dispatch_queue_t delegateQueue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setDelegateQueue: </td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>newDelegateQueue</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the delegate queue param dispatch_queue_t</p>
<p>Sets the delegate queue param dispatch_queue_t </p>

<p>Definition at line <a class="el" href="#L1772">1772</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                        :(dispatch_queue_t)newDelegateQueue
{
    <span class="comment">// Set the delegate queue to the new delegate queue for asynchronous execution of blocks</span>
        [<span class="keyword">self</span> setDelegateQueue:newDelegateQueue synchronously:NO];
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5a64cbec31543316e5318fb1a5caf393"></a><!-- doxytag: member="GCDAsyncSocket::setIPv4Enabled:" ref="a5a64cbec31543316e5318fb1a5caf393" args="(BOOL flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setIPv4Enabled: </td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>flag</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the flag for whether IP version 4 protocol is enabled param BOOL</p>
<p>Sets the flag to enable IP version 4 param BOOL </p>

<p>Definition at line <a class="el" href="#L2012">2012</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                      :(BOOL)flag
{
        <span class="comment">// Note: YES means kIPv4Disabled is OFF</span>
        
    <span class="comment">// The prototype of blocks submitted to dispatch queues, which take no arguments and have no return value.</span>
        dispatch_block_t block = ^{
                
                <span class="keywordflow">if</span> (flag)
        {
                        <a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> &amp;= ~<a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059a5e1715b3fa60f2fe05eaf896dfee0cf8" title="If set, IPv4 is disabled.">kIPv4Disabled</a>;
                }<span class="keywordflow">else</span>{
                        <a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> |= <a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059a5e1715b3fa60f2fe05eaf896dfee0cf8" title="If set, IPv4 is disabled.">kIPv4Disabled</a>;
        }
        }; <span class="comment">// END OF BLOCK</span>
        
    <span class="comment">// Returns the queue on which the currently executing block is running.</span>
    <span class="comment">// In this case, check if the socketQueue is currently running the block</span>
        <span class="keywordflow">if</span> (dispatch_get_current_queue() == <a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>)
    {
                block(); <span class="comment">// submit block for execution</span>
        }<span class="keywordflow">else</span>{
        
        <span class="comment">// Submits block for execution</span>
                dispatch_async(<a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>, block);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a41d137c83f5004f0fb38422b15270d7d"></a><!-- doxytag: member="GCDAsyncSocket::setIPv6Enabled:" ref="a41d137c83f5004f0fb38422b15270d7d" args="(BOOL flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setIPv6Enabled: </td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>flag</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the flag for whether IP version 6 protocol is enabled param BOOL</p>
<p>Sets the flag to enable IP version 6 param BOOL </p>

<p>Definition at line <a class="el" href="#L2073">2073</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                      :(BOOL)flag
{
        <span class="comment">// Note: YES means kIPv6Disabled is OFF</span>
        
    <span class="comment">// The prototype of blocks submitted to dispatch queues, which take no arguments and have no return value.</span>
        dispatch_block_t block = ^{
                
                <span class="keywordflow">if</span> (flag)
        {
                        <a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> &amp;= ~<a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059a94e72322e8d8380318632317bc451eee" title="If set, IPv6 is disabled.">kIPv6Disabled</a>;
            
                }<span class="keywordflow">else</span>{
                        <a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> |= <a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059a94e72322e8d8380318632317bc451eee" title="If set, IPv6 is disabled.">kIPv6Disabled</a>;
        }
        }; <span class="comment">// END OF BLOCK</span>
        
    <span class="comment">// Returns the queue on which the currently executing block is running.</span>
    <span class="comment">// In this case, check if the socketQueue is currently running the block</span>
        <span class="keywordflow">if</span> (dispatch_get_current_queue() == <a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>)
    {
                block(); <span class="comment">// submit block for execution on the queue</span>
        }<span class="keywordflow">else</span>{
        
        <span class="comment">// Executes block asynchronously on the socketQueue</span>
                dispatch_async(<a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>, block);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a73908d258ad70bf185c3ba61fd0a80ab"></a><!-- doxytag: member="GCDAsyncSocket::setPreferIPv4OverIPv6:" ref="a73908d258ad70bf185c3ba61fd0a80ab" args="(BOOL flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setPreferIPv4OverIPv6: </td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>flag</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the flag for whether IP version 4 protocol is preferred over IP version 6 param BOOL</p>
<p>Set the flag for whether IP version 4 is preferred over IP version 6 param BOOL </p>

<p>Definition at line <a class="el" href="#L2133">2133</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                             :(BOOL)flag
{
        <span class="comment">// Note: YES means kPreferIPv6 is OFF</span>
        
    <span class="comment">//  The prototype of blocks submitted to dispatch queues, which take no arguments and have no return value.</span>
        dispatch_block_t block = ^{
                
                <span class="keywordflow">if</span> (flag)
        {
                        <a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> &amp;= ~<a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059ad5d90a1865a0b0c1de05cf862ec91d61" title="If set, IPv6 is preferred over IPv4.">kPreferIPv6</a>;
                }<span class="keywordflow">else</span>{
                        <a class="code" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a> |= <a class="code" href="_g_c_d_async_socket_8m.html#a26088796a96b7cdd928086544a469059ad5d90a1865a0b0c1de05cf862ec91d61" title="If set, IPv6 is preferred over IPv4.">kPreferIPv6</a>;
        }
        };  <span class="comment">// END OF BLOCK</span>
        
    <span class="comment">// Returns the queue on which the currently executing block is running.</span>
    <span class="comment">// In this case, check if the socketQueue is currently running the block</span>
        <span class="keywordflow">if</span> (dispatch_get_current_queue() == <a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>)
    {
                block(); <span class="comment">// executions the block</span>
        
        }<span class="keywordflow">else</span>{
        
        <span class="comment">// Executes the block asynchronously on the socketQueue</span>
                dispatch_async(<a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>, block);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3508a47866b5711e375a7154243f645c"></a><!-- doxytag: member="GCDAsyncSocket::setupReadAndWriteSourcesForNewlyConnectedSocket:" ref="a3508a47866b5711e375a7154243f645c" args="(int socketFD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setupReadAndWriteSourcesForNewlyConnectedSocket: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>socketFD</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Setup the read and write source for a newly connected socket param int </p>

</div>
</div>
<a class="anchor" id="a6a86a4d4cfe0fe4b8132b0f71e151173"></a><!-- doxytag: member="GCDAsyncSocket::setupReadTimerWithTimeout:" ref="a6a86a4d4cfe0fe4b8132b0f71e151173" args="(NSTimeInterval timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setupReadTimerWithTimeout: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Setup the readtime with a time interaval param NSTimeInterval </p>

</div>
</div>
<a class="anchor" id="a1a0e01352480012cdfd6e2b0ab48acfb"></a><!-- doxytag: member="GCDAsyncSocket::setupWriteTimerWithTimeout:" ref="a1a0e01352480012cdfd6e2b0ab48acfb" args="(NSTimeInterval timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setupWriteTimerWithTimeout: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param NSTimeInterval </p>

</div>
</div>
<a class="anchor" id="ad64373d841eb1408af17341cf27067f4"></a><!-- doxytag: member="GCDAsyncSocket::setUserData:" ref="ad64373d841eb1408af17341cf27067f4" args="(id arbitraryUserData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setUserData: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>arbitraryUserData</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param id</p>
<p>Sets userData param id </p>

<p>Definition at line <a class="el" href="#L2199">2199</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                   :(id)arbitraryUserData
{
    <span class="comment">// defines block as a dispatch_block_t type</span>
    <span class="comment">// doesn&#39;t accept any arguements</span>
        dispatch_block_t block = ^{
                
                <span class="keywordflow">if</span> (<a class="code" href="interface_g_c_d_async_socket.html#ab46069d6ffbcb6a0bb1eae5aaaafe94a">userData</a> != arbitraryUserData)
                {
                        [userData release];
                        <a class="code" href="interface_g_c_d_async_socket.html#ab46069d6ffbcb6a0bb1eae5aaaafe94a">userData</a> = [arbitraryUserData retain];
                }
        }; <span class="comment">//end of block</span>
    
    <span class="comment">// Returns the queue on which the currently executing block is running.</span>
    <span class="comment">// In this case, check if the socketQueue is currently running the block</span>
        <span class="keywordflow">if</span> (dispatch_get_current_queue() == <a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>)
    {
                block(); <span class="comment">// executes the block</span>
        
    }<span class="keywordflow">else</span>{
        
        <span class="comment">// Executes the block asychronously on the socketQueue</span>
                dispatch_async(<a class="code" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a>, block);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2b9c119ffa6ff18321572f26a759b9ed"></a><!-- doxytag: member="GCDAsyncSocket::socket4FD" ref="a2b9c119ffa6ff18321572f26a759b9ed" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (int) <a class="el" href="interface_g_c_d_async_socket.html#a5e9a52b6037bb7ca77d20ff6cdf009e7">socket4FD</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns int </p>

</div>
</div>
<a class="anchor" id="ad6120d297c599aff1e50bd2ce917e3ad"></a><!-- doxytag: member="GCDAsyncSocket::socket6FD" ref="ad6120d297c599aff1e50bd2ce917e3ad" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (int) <a class="el" href="interface_g_c_d_async_socket.html#a76b50c6289ef8990165376846c312fc2">socket6FD</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns int </p>

</div>
</div>
<a class="anchor" id="ad7cd01612683e0994e7ef2fadf77952e"></a><!-- doxytag: member="GCDAsyncSocket::socketFD" ref="ad7cd01612683e0994e7ef2fadf77952e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (int) socketFD </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These methods are only available from within the context of a performBlock: invocation. See the documentation for the performBlock: method above.</p>
<p>Provides access to the socket's file descriptor(s). If the socket is a server socket (is accepting incoming connections), it might actually have multiple internal socket file descriptors - one for IPv4 and one for IPv6. </p>

</div>
</div>
<a class="anchor" id="a09f53a1bc824259a55ff249183111beb"></a><!-- doxytag: member="GCDAsyncSocket::sslContext" ref="a09f53a1bc824259a55ff249183111beb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (SSLContextRef) <a class="el" href="interface_g_c_d_async_socket.html#abc0b34177c702ee1e5f0e10c4cd6f8a7">sslContext</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is only available from within the context of a performBlock: invocation. See the documentation for the performBlock: method above.</p>
<p>Provides access to the socket's SSLContext, if SSL/TLS has been started on the socket. </p>

</div>
</div>
<a class="anchor" id="a6a35d03945525a87faa9428bfd284fb8"></a><!-- doxytag: member="GCDAsyncSocket::startConnectTimeout:" ref="a6a35d03945525a87faa9428bfd284fb8" args="(NSTimeInterval timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) startConnectTimeout: </td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param NSTimeInterval </p>

</div>
</div>
<a class="anchor" id="aec4d670add3f78c669277990d7b48056"></a><!-- doxytag: member="GCDAsyncSocket::startTLS:" ref="aec4d670add3f78c669277990d7b48056" args="(NSDictionary *tlsSettings)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) startTLS: </td>
          <td></td>
          <td class="paramtype">(NSDictionary *)&#160;</td>
          <td class="paramname"><em>tlsSettings</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Secures the connection using SSL/TLS.</p>
<p>This method may be called at any time, and the TLS handshake will occur after all pending reads and writes are finished. This allows one the option of sending a protocol dependent StartTLS message, and queuing the upgrade to TLS at the same time, without having to wait for the write to finish. Any reads or writes scheduled after this method is called will occur over the secured connection.</p>
<p>The possible keys and values for the TLS settings are well documented. Some possible keys are:</p>
<ul>
<li>kCFStreamSSLLevel</li>
<li>kCFStreamSSLAllowsExpiredCertificates</li>
<li>kCFStreamSSLAllowsExpiredRoots</li>
<li>kCFStreamSSLAllowsAnyRoot</li>
<li>kCFStreamSSLValidatesCertificateChain</li>
<li>kCFStreamSSLPeerName</li>
<li>kCFStreamSSLCertificates</li>
<li>kCFStreamSSLIsServer</li>
</ul>
<p>Please refer to Apple's documentation for associated values, as well as other possible keys.</p>
<p>If you pass in nil or an empty dictionary, the default settings will be used.</p>
<p>The default settings will check to make sure the remote party's certificate is signed by a trusted 3rd party certificate agency (e.g. verisign) and that the certificate is not expired. However it will not verify the name on the certificate unless you give it a name to verify against via the kCFStreamSSLPeerName key. The security implications of this are important to understand. Imagine you are attempting to create a secure connection to MySecureServer.com, but your socket gets directed to MaliciousServer.com because of a hacked DNS server. If you simply use the default settings, and MaliciousServer.com has a valid certificate, the default settings will not detect any problems since the certificate is valid. To properly secure your connection in this particular scenario you should set the kCFStreamSSLPeerName property to "MySecureServer.com". If you do not know the peer name of the remote host in advance (for example, you're not sure if it will be "domain.com" or "www.domain.com"), then you can use the default settings to validate the certificate, and then use the X509Certificate class to verify the issuer after the socket has been secured. The X509Certificate class is part of the CocoaAsyncSocket open source project. </p>

</div>
</div>
<a class="anchor" id="a02f78d565bb4c1527f8b278bf926821f"></a><!-- doxytag: member="GCDAsyncSocket::suspendReadSource" ref="a02f78d565bb4c1527f8b278bf926821f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) suspendReadSource </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Suspends the read source </p>

</div>
</div>
<a class="anchor" id="acb866c203e932f8028d08be4d3cea0b8"></a><!-- doxytag: member="GCDAsyncSocket::suspendWriteSource" ref="acb866c203e932f8028d08be4d3cea0b8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) suspendWriteSource </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Suspends the write source </p>

</div>
</div>
<a class="anchor" id="aa5625ed5c76085530b96dc6c5e2839d1"></a><!-- doxytag: member="GCDAsyncSocket::synchronouslySetDelegate:" ref="aa5625ed5c76085530b96dc6c5e2839d1" args="(id delegate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) synchronouslySetDelegate: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>newDelegate</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Synchronously sets the delegate param id</p>
<p>Set the delegate as a new delegate param id </p>

<p>Definition at line <a class="el" href="#L1687">1687</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                                :(id)newDelegate
{
    <span class="comment">// Set the delegate as the newDelegate for synchronous execution of blocks</span>
        [<span class="keyword">self</span> setDelegate:newDelegate synchronously:YES];
}
</pre></div>
</div>
</div>
<a class="anchor" id="a16ada359e981e7021f834a467cd47558"></a><!-- doxytag: member="GCDAsyncSocket::synchronouslySetDelegate:delegateQueue:" ref="a16ada359e981e7021f834a467cd47558" args="(id delegate,[delegateQueue] dispatch_queue_t delegateQueue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) synchronouslySetDelegate: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>newDelegate</em></td>
        </tr>
        <tr>
          <td class="paramkey">delegateQueue:</td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>newDelegateQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Synchronously set the delegate and delegate queue param id param dispatch_queue_t</p>
<p>Set delegate for delgate queuue param id param dispatch_queue_t </p>

<p>Definition at line <a class="el" href="#L1913">1913</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                                :(id)newDelegate <a class="code" href="interface_g_c_d_async_socket.html#ad8e601f3e3e4ec791f9a7741ff12aec5">delegateQueue</a>:(dispatch_queue_t)newDelegateQueue
{
        [<span class="keyword">self</span> setDelegate:newDelegate delegateQueue:newDelegateQueue synchronously:YES];
}
</pre></div>
</div>
</div>
<a class="anchor" id="ababced98cdedb94928d4e96b86005f8f"></a><!-- doxytag: member="GCDAsyncSocket::synchronouslySetDelegateQueue:" ref="ababced98cdedb94928d4e96b86005f8f" args="(dispatch_queue_t delegateQueue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) synchronouslySetDelegateQueue: </td>
          <td></td>
          <td class="paramtype">(dispatch_queue_t)&#160;</td>
          <td class="paramname"><em>newDelegateQueue</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>param dispatch_queue_t</p>
<p>Sets the delegate queue param dispatch_queue_t </p>

<p>Definition at line <a class="el" href="#L1782">1782</a> of file <a class="el" href="">GCDAsyncSocket.m</a>.</p>
<div class="fragment"><pre class="fragment">                                     :(dispatch_queue_t)newDelegateQueue
{
    <span class="comment">// Set the delegate queue to the new delegate queue for synchronous execution of blocks</span>
        [<span class="keyword">self</span> setDelegateQueue:newDelegateQueue synchronously:YES];
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab46069d6ffbcb6a0bb1eae5aaaafe94a"></a><!-- doxytag: member="GCDAsyncSocket::userData" ref="ab46069d6ffbcb6a0bb1eae5aaaafe94a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) <a class="el" href="interface_g_c_d_async_socket.html#aaed3930744ea96721de0752032e8f541">userData</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>User data allows you to associate arbitrary information with the socket. This data is not used internally by socket in any way. returns id </p>

</div>
</div>
<a class="anchor" id="a7f85c2e3c19bbe013c180b4668a28fc2"></a><!-- doxytag: member="GCDAsyncSocket::writeData:withTimeout:tag:" ref="a7f85c2e3c19bbe013c180b4668a28fc2" args="(NSData *data,[withTimeout] NSTimeInterval timeout,[tag] long tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) writeData: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_n_s_data.html">NSData</a> *)&#160;</td>
          <td class="paramname"><em>data</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTimeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&#160;</td>
          <td class="paramname"><em>timeout</em></td>
        </tr>
        <tr>
          <td class="paramkey">tag:</td>
          <td></td>
          <td class="paramtype">(long)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes data to the socket, and calls the delegate when finished.</p>
<p>If you pass in nil or zero-length data, this method does nothing and the delegate will not be called. If the timeout value is negative, the write operation will not use a timeout. </p>

</div>
</div>
<a class="anchor" id="aa051f54bdd6c087a6b4a51c799dbc68b"></a><!-- doxytag: member="GCDAsyncSocket::ZeroData" ref="aa051f54bdd6c087a6b4a51c799dbc68b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (<a class="el" href="class_n_s_data.html">NSData</a> *) ZeroData </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class method returns <a class="el" href="class_n_s_data.html">NSData</a> </p>

</div>
</div>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a0258b7b16069bcc876876f11f5bfbf00"></a><!-- doxytag: member="GCDAsyncSocket::accept4Source" ref="a0258b7b16069bcc876876f11f5bfbf00" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (dispatch_source_t) <a class="el" href="interface_g_c_d_async_socket.html#a0258b7b16069bcc876876f11f5bfbf00">accept4Source</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dispatch sources are used to automatically submit event handler blocks to dispatch queues in response to external events. </p>

<p>Definition at line <a class="el" href="#L106">106</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a003699eaada0bca7f6036a850e9ded20"></a><!-- doxytag: member="GCDAsyncSocket::accept6Source" ref="a003699eaada0bca7f6036a850e9ded20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (dispatch_source_t) <a class="el" href="interface_g_c_d_async_socket.html#a003699eaada0bca7f6036a850e9ded20">accept6Source</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dispatch sources are used to automatically submit event handler blocks to dispatch queues in response to external events. </p>

<p>Definition at line <a class="el" href="#L111">111</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5c290f34d5ff21a69e1c54033a629731"></a><!-- doxytag: member="GCDAsyncSocket::config" ref="a5c290f34d5ff21a69e1c54033a629731" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) <a class="el" href="interface_g_c_d_async_socket.html#a5c290f34d5ff21a69e1c54033a629731">config</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="#L62">62</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="adead8a55f9eb7ea6b017928b8f07ba88"></a><!-- doxytag: member="GCDAsyncSocket::connectIndex" ref="adead8a55f9eb7ea6b017928b8f07ba88" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (int) <a class="el" href="interface_g_c_d_async_socket.html#adead8a55f9eb7ea6b017928b8f07ba88">connectIndex</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="#L85">85</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad95ce3c72099d8264f7d11b80086577f"></a><!-- doxytag: member="GCDAsyncSocket::connectInterface4" ref="ad95ce3c72099d8264f7d11b80086577f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="class_n_s_data.html">NSData</a>*) <a class="el" href="interface_g_c_d_async_socket.html#ad95ce3c72099d8264f7d11b80086577f">connectInterface4</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Object-oriented wrappers for byte buffers IP version 4 interface </p>

<p>Definition at line <a class="el" href="#L91">91</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae1dcf5b9961daf9d6a2d3554cd35793c"></a><!-- doxytag: member="GCDAsyncSocket::connectInterface6" ref="ae1dcf5b9961daf9d6a2d3554cd35793c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="class_n_s_data.html">NSData</a>*) <a class="el" href="interface_g_c_d_async_socket.html#ae1dcf5b9961daf9d6a2d3554cd35793c">connectInterface6</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>IP version 6 interface </p>

<p>Definition at line <a class="el" href="#L96">96</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2878c7d9cca5a4b7a557358db8559abd"></a><!-- doxytag: member="GCDAsyncSocket::connectTimer" ref="a2878c7d9cca5a4b7a557358db8559abd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (dispatch_source_t) <a class="el" href="interface_g_c_d_async_socket.html#a2878c7d9cca5a4b7a557358db8559abd">connectTimer</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dispatch sources are used to automatically submit event handler blocks to dispatch queues in response to external events. </p>

<p>Definition at line <a class="el" href="#L116">116</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac6eeee8bb60215eea067cdfcb844f557"></a><!-- doxytag: member="GCDAsyncSocket::currentRead" ref="ac6eeee8bb60215eea067cdfcb844f557" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_g_c_d_async_read_packet.html">GCDAsyncReadPacket</a>*) <a class="el" href="interface_g_c_d_async_socket.html#ac6eeee8bb60215eea067cdfcb844f557">currentRead</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>the read packet </p>

<p>Definition at line <a class="el" href="#L153">153</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4b3234a5bb213a8af4cf4b3e3f2548e5"></a><!-- doxytag: member="GCDAsyncSocket::currentWrite" ref="a4b3234a5bb213a8af4cf4b3e3f2548e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_g_c_d_async_write_packet.html">GCDAsyncWritePacket</a>*) <a class="el" href="interface_g_c_d_async_socket.html#a4b3234a5bb213a8af4cf4b3e3f2548e5">currentWrite</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>the write packet </p>

<p>Definition at line <a class="el" href="#L158">158</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8d9332fcd23523b1e2520b8765577423"></a><!-- doxytag: member="GCDAsyncSocket::delegate" ref="a8d9332fcd23523b1e2520b8765577423" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) <a class="el" href="interface_g_c_d_async_socket.html#a8d9332fcd23523b1e2520b8765577423">delegate</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the delegate off the socketQueue returns id </p>

<p>Definition at line <a class="el" href="#L67">67</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a97158c52f2a4011454b4eb3ee369a8a1"></a><!-- doxytag: member="GCDAsyncSocket::delegateQueue" ref="a97158c52f2a4011454b4eb3ee369a8a1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (dispatch_queue_t) <a class="el" href="interface_g_c_d_async_socket.html#a97158c52f2a4011454b4eb3ee369a8a1">delegateQueue</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dispatch queues are lightweight objects to which blocks may be submitted. The system manages a pool of threads which process dispatch queues and invoke blocks submitted to them.</p>
<p>Gets the delegateQueue returns dispatch_queue_t </p>

<p>Definition at line <a class="el" href="#L73">73</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0c12680bebc888c6b3a967c074c1b53b"></a><!-- doxytag: member="GCDAsyncSocket::flags" ref="a0c12680bebc888c6b3a967c074c1b53b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (UInt16) <a class="el" href="interface_g_c_d_async_socket.html#a0c12680bebc888c6b3a967c074c1b53b">flags</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="#L56">56</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2c92583ab159460443b3d9b73b2b4156"></a><!-- doxytag: member="GCDAsyncSocket::partialReadBuffer" ref="a2c92583ab159460443b3d9b73b2b4156" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSMutableData*) <a class="el" href="interface_g_c_d_async_socket.html#a2c92583ab159460443b3d9b73b2b4156">partialReadBuffer</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A partial read buffer for buffering the host request </p>

<p>Definition at line <a class="el" href="#L169">169</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a93d45803a1d4682aaefb278b0a2bd93f"></a><!-- doxytag: member="GCDAsyncSocket::readQueue" ref="a93d45803a1d4682aaefb278b0a2bd93f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSMutableArray*) <a class="el" href="interface_g_c_d_async_socket.html#a93d45803a1d4682aaefb278b0a2bd93f">readQueue</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The read queue </p>

<p>Definition at line <a class="el" href="#L142">142</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a54a3d7f734424b2d249a1a246021ab7f"></a><!-- doxytag: member="GCDAsyncSocket::readSource" ref="a54a3d7f734424b2d249a1a246021ab7f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (dispatch_source_t) <a class="el" href="interface_g_c_d_async_socket.html#a54a3d7f734424b2d249a1a246021ab7f">readSource</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dispatch sources are used to automatically submit event handler blocks to dispatch queues in response to external events. </p>

<p>Definition at line <a class="el" href="#L121">121</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a24e3b4a8ae9be3aad363801c2f92f75e"></a><!-- doxytag: member="GCDAsyncSocket::readTimer" ref="a24e3b4a8ae9be3aad363801c2f92f75e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (dispatch_source_t) <a class="el" href="interface_g_c_d_async_socket.html#a24e3b4a8ae9be3aad363801c2f92f75e">readTimer</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dispatch sources are used to automatically submit event handler blocks to dispatch queues in response to external events. </p>

<p>Definition at line <a class="el" href="#L131">131</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5e9a52b6037bb7ca77d20ff6cdf009e7"></a><!-- doxytag: member="GCDAsyncSocket::socket4FD" ref="a5e9a52b6037bb7ca77d20ff6cdf009e7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (int) <a class="el" href="interface_g_c_d_async_socket.html#a5e9a52b6037bb7ca77d20ff6cdf009e7">socket4FD</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>IP version 4 socket file descriptor </p>

<p>Definition at line <a class="el" href="#L78">78</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a76b50c6289ef8990165376846c312fc2"></a><!-- doxytag: member="GCDAsyncSocket::socket6FD" ref="a76b50c6289ef8990165376846c312fc2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (int) <a class="el" href="interface_g_c_d_async_socket.html#a76b50c6289ef8990165376846c312fc2">socket6FD</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>IP version 6 socket file descriptor </p>

<p>Definition at line <a class="el" href="#L83">83</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a608e58eacfd78e9223f9a34eb3af30d9"></a><!-- doxytag: member="GCDAsyncSocket::socketFDBytesAvailable" ref="a608e58eacfd78e9223f9a34eb3af30d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (unsigned long) <a class="el" href="interface_g_c_d_async_socket.html#a608e58eacfd78e9223f9a34eb3af30d9">socketFDBytesAvailable</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>socket file descriptor bytes available Value is 0 to 2,147,483,647 </p>

<p>Definition at line <a class="el" href="#L164">164</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a744b3bca1e96465ef18810298db8439e"></a><!-- doxytag: member="GCDAsyncSocket::socketQueue" ref="a744b3bca1e96465ef18810298db8439e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (dispatch_queue_t) <a class="el" href="interface_g_c_d_async_socket.html#a744b3bca1e96465ef18810298db8439e">socketQueue</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The dispatch queue upon which blocks are submitted </p>

<p>Definition at line <a class="el" href="#L101">101</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="abc0b34177c702ee1e5f0e10c4cd6f8a7"></a><!-- doxytag: member="GCDAsyncSocket::sslContext" ref="abc0b34177c702ee1e5f0e10c4cd6f8a7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (SSLContextRef) <a class="el" href="interface_g_c_d_async_socket.html#abc0b34177c702ee1e5f0e10c4cd6f8a7">sslContext</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>the SSL context reference </p>

<p>Definition at line <a class="el" href="#L193">193</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="adb68739cb718c58bd309456690e52aca"></a><!-- doxytag: member="GCDAsyncSocket::sslReadBuffer" ref="adb68739cb718c58bd309456690e52aca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSMutableData*) <a class="el" href="interface_g_c_d_async_socket.html#adb68739cb718c58bd309456690e52aca">sslReadBuffer</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The SSL read buffer for buffering the host response </p>

<p>Definition at line <a class="el" href="#L198">198</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a87060da8aee33ea041edcf0490262651"></a><!-- doxytag: member="GCDAsyncSocket::sslWriteCachedLength" ref="a87060da8aee33ea041edcf0490262651" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (size_t) <a class="el" href="interface_g_c_d_async_socket.html#a87060da8aee33ea041edcf0490262651">sslWriteCachedLength</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>size of the SSL write cache </p>

<p>Definition at line <a class="el" href="#L203">203</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaed3930744ea96721de0752032e8f541"></a><!-- doxytag: member="GCDAsyncSocket::userData" ref="aaed3930744ea96721de0752032e8f541" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) <a class="el" href="interface_g_c_d_async_socket.html#aaed3930744ea96721de0752032e8f541">userData</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>user data</p>
<p>Gets the userData User data allows you to associate arbitrary information with the socket. This data is not used internally by socket in any way. returns id </p>

<p>Definition at line <a class="el" href="#L210">210</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1ad8da0672218827b7a1a4abbdf1f34d"></a><!-- doxytag: member="GCDAsyncSocket::writeQueue" ref="a1ad8da0672218827b7a1a4abbdf1f34d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSMutableArray*) <a class="el" href="interface_g_c_d_async_socket.html#a1ad8da0672218827b7a1a4abbdf1f34d">writeQueue</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>the write queue </p>

<p>Definition at line <a class="el" href="#L147">147</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa43b40a19fac92685a75405df0cdaccf"></a><!-- doxytag: member="GCDAsyncSocket::writeSource" ref="aa43b40a19fac92685a75405df0cdaccf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (dispatch_source_t) <a class="el" href="interface_g_c_d_async_socket.html#aa43b40a19fac92685a75405df0cdaccf">writeSource</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dispatch sources are used to automatically submit event handler blocks to dispatch queues in response to external events. </p>

<p>Definition at line <a class="el" href="#L126">126</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0f701534080cce80a769478c6063ddbc"></a><!-- doxytag: member="GCDAsyncSocket::writeTimer" ref="a0f701534080cce80a769478c6063ddbc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (dispatch_source_t) <a class="el" href="interface_g_c_d_async_socket.html#a0f701534080cce80a769478c6063ddbc">writeTimer</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dispatch sources are used to automatically submit event handler blocks to dispatch queues in response to external events. </p>

<p>Definition at line <a class="el" href="#L136">136</a> of file <a class="el" href="">GCDAsyncSocket.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/willrubel/IOS-Streaming-Browser/IOS-Streaming-Browser/<a class="el" href="">GCDAsyncSocket.h</a></li>
<li>/Users/willrubel/IOS-Streaming-Browser/IOS-Streaming-Browser/<a class="el" href="">GCDAsyncSocket.m</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="interface_g_c_d_async_socket.html">GCDAsyncSocket</a>      </li>
      <li class="footer">Generated on Sat Jun 4 2011 18:45:29 for IOS Streaming Browser by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
